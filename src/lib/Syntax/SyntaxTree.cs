// <auto-generated />

#nullable enable

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;

namespace Flare.Syntax
{
    public sealed class ModulePathNode : SyntaxNode
    {
        public SeparatedSyntaxTokenList ComponentTokens { get; }

        public override bool HasTokens
        {
            get
            {
                if (ComponentTokens.Tokens.Count != 0)
                    return true;
                if (ComponentTokens.Separators.Count != 0)
                    return true;

                return false;
            }
        }

        public override bool HasChildren => false;

        internal ModulePathNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            SeparatedSyntaxTokenList componentTokens)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                componentTokens)
        {
        }

        ModulePathNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            SeparatedSyntaxTokenList componentTokens)
            : base(skipped, diagnostics, annotations)
        {
            ComponentTokens = componentTokens;
            foreach (var child in componentTokens.Tokens)
                child.Parent = this;
            foreach (var child in componentTokens.Separators)
                child.Parent = this;
        }

        public ModulePathNode DeepClone()
        {
            return new ModulePathNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                ComponentTokens.DeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            foreach (var token in ComponentTokens.Tokens)
                yield return token;
            foreach (var token in ComponentTokens.Separators)
                yield return token;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            return Array.Empty<SyntaxNode>();
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class ProgramNode : SyntaxNode
    {
        public SyntaxNodeList<AttributeNode> Attributes { get; }

        public SyntaxToken ModKeywordToken { get; }

        public ModulePathNode Path { get; }

        public SyntaxToken SemicolonToken { get; }

        public SyntaxNodeList<DeclarationNode> Declarations { get; }

        public override bool HasTokens => true;

        public override bool HasChildren => true;

        internal ProgramNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            SyntaxNodeList<AttributeNode> attributes,
            SyntaxToken modKeywordToken,
            ModulePathNode path,
            SyntaxToken semicolonToken,
            SyntaxNodeList<DeclarationNode> declarations)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                attributes,
                modKeywordToken,
                path,
                semicolonToken,
                declarations)
        {
        }

        ProgramNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            SyntaxNodeList<AttributeNode> attributes,
            SyntaxToken modKeywordToken,
            ModulePathNode path,
            SyntaxToken semicolonToken,
            SyntaxNodeList<DeclarationNode> declarations)
            : base(skipped, diagnostics, annotations)
        {
            Attributes = attributes;
            foreach (var child in attributes)
                child.Parent = this;

            ModKeywordToken = modKeywordToken;
            modKeywordToken.Parent = this;

            Path = path;
            path.Parent = this;

            SemicolonToken = semicolonToken;
            semicolonToken.Parent = this;

            Declarations = declarations;
            foreach (var child in declarations)
                child.Parent = this;
        }

        public ProgramNode DeepClone()
        {
            return new ProgramNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                Attributes.DeepClone(),
                ModKeywordToken.DeepClone(),
                (ModulePathNode)Path.InternalDeepClone(),
                SemicolonToken.DeepClone(),
                Declarations.DeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            yield return ModKeywordToken;

            yield return SemicolonToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            foreach (var child in Attributes)
                yield return child;

            yield return Path;

            foreach (var child in Declarations)
                yield return child;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class InteractiveNode : SyntaxNode
    {
        public SyntaxNodeList<DeclarationNode> Declarations { get; }

        public SyntaxNodeList<StatementNode> Statements { get; }

        public override bool HasTokens => false;

        public override bool HasChildren
        {
            get
            {
                if (Declarations.Count != 0)
                    return true;

                if (Statements.Count != 0)
                    return true;

                return false;
            }
        }

        internal InteractiveNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            SyntaxNodeList<DeclarationNode> declarations,
            SyntaxNodeList<StatementNode> statements)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                declarations,
                statements)
        {
        }

        InteractiveNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            SyntaxNodeList<DeclarationNode> declarations,
            SyntaxNodeList<StatementNode> statements)
            : base(skipped, diagnostics, annotations)
        {
            Declarations = declarations;
            foreach (var child in declarations)
                child.Parent = this;

            Statements = statements;
            foreach (var child in statements)
                child.Parent = this;
        }

        public InteractiveNode DeepClone()
        {
            return new InteractiveNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                Declarations.DeepClone(),
                Statements.DeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            return Array.Empty<SyntaxToken>();
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            foreach (var child in Declarations)
                yield return child;

            foreach (var child in Statements)
                yield return child;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class AttributeNode : SyntaxNode
    {
        public SyntaxToken AtToken { get; }

        public SyntaxToken OpenBracketToken { get; }

        public SyntaxToken NameToken { get; }

        public SyntaxToken EqualsToken { get; }

        public SyntaxToken ValueToken { get; }

        public SyntaxToken CloseBracketToken { get; }

        public override bool HasTokens => true;

        public override bool HasChildren => false;

        internal AttributeNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            SyntaxToken atToken,
            SyntaxToken openBracketToken,
            SyntaxToken nameToken,
            SyntaxToken equalsToken,
            SyntaxToken valueToken,
            SyntaxToken closeBracketToken)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                atToken,
                openBracketToken,
                nameToken,
                equalsToken,
                valueToken,
                closeBracketToken)
        {
        }

        AttributeNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            SyntaxToken atToken,
            SyntaxToken openBracketToken,
            SyntaxToken nameToken,
            SyntaxToken equalsToken,
            SyntaxToken valueToken,
            SyntaxToken closeBracketToken)
            : base(skipped, diagnostics, annotations)
        {
            AtToken = atToken;
            atToken.Parent = this;

            OpenBracketToken = openBracketToken;
            openBracketToken.Parent = this;

            NameToken = nameToken;
            nameToken.Parent = this;

            EqualsToken = equalsToken;
            equalsToken.Parent = this;

            ValueToken = valueToken;
            valueToken.Parent = this;

            CloseBracketToken = closeBracketToken;
            closeBracketToken.Parent = this;
        }

        public AttributeNode DeepClone()
        {
            return new AttributeNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                AtToken.DeepClone(),
                OpenBracketToken.DeepClone(),
                NameToken.DeepClone(),
                EqualsToken.DeepClone(),
                ValueToken.DeepClone(),
                CloseBracketToken.DeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            yield return AtToken;

            yield return OpenBracketToken;

            yield return NameToken;

            yield return EqualsToken;

            yield return ValueToken;

            yield return CloseBracketToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            return Array.Empty<SyntaxNode>();
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public abstract class DeclarationNode : SyntaxNode
    {
        public abstract SyntaxNodeList<AttributeNode> Attributes { get; }

        public abstract SyntaxToken KeywordToken { get; }

        private protected DeclarationNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations)
                : base(skipped, diagnostics, annotations)
        {
        }
    }

    public sealed class UseDeclarationNode : DeclarationNode
    {
        public override SyntaxNodeList<AttributeNode> Attributes { get; }

        public override SyntaxToken KeywordToken { get; }

        public ModulePathNode Path { get; }

        public UseDeclarationAliasNode? Alias { get; }

        public SyntaxToken SemicolonToken { get; }

        public override bool HasTokens => true;

        public override bool HasChildren => true;

        internal UseDeclarationNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            SyntaxNodeList<AttributeNode> attributes,
            SyntaxToken keywordToken,
            ModulePathNode path,
            UseDeclarationAliasNode? alias,
            SyntaxToken semicolonToken)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                attributes,
                keywordToken,
                path,
                alias,
                semicolonToken)
        {
        }

        UseDeclarationNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            SyntaxNodeList<AttributeNode> attributes,
            SyntaxToken keywordToken,
            ModulePathNode path,
            UseDeclarationAliasNode? alias,
            SyntaxToken semicolonToken)
            : base(skipped, diagnostics, annotations)
        {
            Attributes = attributes;
            foreach (var child in attributes)
                child.Parent = this;

            KeywordToken = keywordToken;
            keywordToken.Parent = this;

            Path = path;
            path.Parent = this;

            Alias = alias;
            if (alias != null)
                alias.Parent = this;

            SemicolonToken = semicolonToken;
            semicolonToken.Parent = this;
        }

        public UseDeclarationNode DeepClone()
        {
            return new UseDeclarationNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                Attributes.DeepClone(),
                KeywordToken.DeepClone(),
                (ModulePathNode)Path.InternalDeepClone(),
                (UseDeclarationAliasNode?)Alias?.InternalDeepClone(),
                SemicolonToken.DeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            yield return KeywordToken;

            yield return SemicolonToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            foreach (var child in Attributes)
                yield return child;

            yield return Path;

            if (Alias != null)
                yield return Alias;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class UseDeclarationAliasNode : SyntaxNode
    {
        public SyntaxToken AsKeywordToken { get; }

        public SyntaxToken NameToken { get; }

        public override bool HasTokens => true;

        public override bool HasChildren => false;

        internal UseDeclarationAliasNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            SyntaxToken asKeywordToken,
            SyntaxToken nameToken)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                asKeywordToken,
                nameToken)
        {
        }

        UseDeclarationAliasNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            SyntaxToken asKeywordToken,
            SyntaxToken nameToken)
            : base(skipped, diagnostics, annotations)
        {
            AsKeywordToken = asKeywordToken;
            asKeywordToken.Parent = this;

            NameToken = nameToken;
            nameToken.Parent = this;
        }

        public UseDeclarationAliasNode DeepClone()
        {
            return new UseDeclarationAliasNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                AsKeywordToken.DeepClone(),
                NameToken.DeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            yield return AsKeywordToken;

            yield return NameToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            return Array.Empty<SyntaxNode>();
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class TestDeclarationNode : DeclarationNode
    {
        public override SyntaxNodeList<AttributeNode> Attributes { get; }

        public override SyntaxToken KeywordToken { get; }

        public SyntaxToken NameToken { get; }

        public BlockExpressionNode Body { get; }

        public override bool HasTokens => true;

        public override bool HasChildren => true;

        internal TestDeclarationNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            SyntaxNodeList<AttributeNode> attributes,
            SyntaxToken keywordToken,
            SyntaxToken nameToken,
            BlockExpressionNode body)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                attributes,
                keywordToken,
                nameToken,
                body)
        {
        }

        TestDeclarationNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            SyntaxNodeList<AttributeNode> attributes,
            SyntaxToken keywordToken,
            SyntaxToken nameToken,
            BlockExpressionNode body)
            : base(skipped, diagnostics, annotations)
        {
            Attributes = attributes;
            foreach (var child in attributes)
                child.Parent = this;

            KeywordToken = keywordToken;
            keywordToken.Parent = this;

            NameToken = nameToken;
            nameToken.Parent = this;

            Body = body;
            body.Parent = this;
        }

        public TestDeclarationNode DeepClone()
        {
            return new TestDeclarationNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                Attributes.DeepClone(),
                KeywordToken.DeepClone(),
                NameToken.DeepClone(),
                (BlockExpressionNode)Body.InternalDeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            yield return KeywordToken;

            yield return NameToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            foreach (var child in Attributes)
                yield return child;

            yield return Body;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public abstract class NamedDeclarationNode : DeclarationNode
    {
        public abstract SyntaxToken? VisibilityKeywordToken { get; }

        public abstract SyntaxToken NameToken { get; }

        private protected NamedDeclarationNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations)
                : base(skipped, diagnostics, annotations)
        {
        }
    }

    public sealed class MissingNamedDeclarationNode : NamedDeclarationNode
    {
        public override SyntaxNodeList<AttributeNode> Attributes { get; }

        public override SyntaxToken? VisibilityKeywordToken { get; }

        public override SyntaxToken KeywordToken { get; }

        public override SyntaxToken NameToken { get; }

        public override bool HasTokens => true;

        public override bool HasChildren
        {
            get
            {
                if (Attributes.Count != 0)
                    return true;

                return false;
            }
        }

        internal MissingNamedDeclarationNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            SyntaxNodeList<AttributeNode> attributes,
            SyntaxToken? visibilityKeywordToken,
            SyntaxToken keywordToken,
            SyntaxToken nameToken)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                attributes,
                visibilityKeywordToken,
                keywordToken,
                nameToken)
        {
        }

        MissingNamedDeclarationNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            SyntaxNodeList<AttributeNode> attributes,
            SyntaxToken? visibilityKeywordToken,
            SyntaxToken keywordToken,
            SyntaxToken nameToken)
            : base(skipped, diagnostics, annotations)
        {
            Attributes = attributes;
            foreach (var child in attributes)
                child.Parent = this;

            VisibilityKeywordToken = visibilityKeywordToken;
            if (visibilityKeywordToken != null)
                visibilityKeywordToken.Parent = this;

            KeywordToken = keywordToken;
            keywordToken.Parent = this;

            NameToken = nameToken;
            nameToken.Parent = this;
        }

        public MissingNamedDeclarationNode DeepClone()
        {
            return new MissingNamedDeclarationNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                Attributes.DeepClone(),
                VisibilityKeywordToken?.DeepClone(),
                KeywordToken.DeepClone(),
                NameToken.DeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            if (VisibilityKeywordToken != null)
                yield return VisibilityKeywordToken;

            yield return KeywordToken;

            yield return NameToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            foreach (var child in Attributes)
                yield return child;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class ConstantDeclarationNode : NamedDeclarationNode
    {
        public override SyntaxNodeList<AttributeNode> Attributes { get; }

        public override SyntaxToken? VisibilityKeywordToken { get; }

        public override SyntaxToken KeywordToken { get; }

        public override SyntaxToken NameToken { get; }

        public SyntaxToken EqualsToken { get; }

        public ExpressionNode Initializer { get; }

        public SyntaxToken SemicolonToken { get; }

        public override bool HasTokens => true;

        public override bool HasChildren => true;

        internal ConstantDeclarationNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            SyntaxNodeList<AttributeNode> attributes,
            SyntaxToken? visibilityKeywordToken,
            SyntaxToken keywordToken,
            SyntaxToken nameToken,
            SyntaxToken equalsToken,
            ExpressionNode initializer,
            SyntaxToken semicolonToken)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                attributes,
                visibilityKeywordToken,
                keywordToken,
                nameToken,
                equalsToken,
                initializer,
                semicolonToken)
        {
        }

        ConstantDeclarationNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            SyntaxNodeList<AttributeNode> attributes,
            SyntaxToken? visibilityKeywordToken,
            SyntaxToken keywordToken,
            SyntaxToken nameToken,
            SyntaxToken equalsToken,
            ExpressionNode initializer,
            SyntaxToken semicolonToken)
            : base(skipped, diagnostics, annotations)
        {
            Attributes = attributes;
            foreach (var child in attributes)
                child.Parent = this;

            VisibilityKeywordToken = visibilityKeywordToken;
            if (visibilityKeywordToken != null)
                visibilityKeywordToken.Parent = this;

            KeywordToken = keywordToken;
            keywordToken.Parent = this;

            NameToken = nameToken;
            nameToken.Parent = this;

            EqualsToken = equalsToken;
            equalsToken.Parent = this;

            Initializer = initializer;
            initializer.Parent = this;

            SemicolonToken = semicolonToken;
            semicolonToken.Parent = this;
        }

        public ConstantDeclarationNode DeepClone()
        {
            return new ConstantDeclarationNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                Attributes.DeepClone(),
                VisibilityKeywordToken?.DeepClone(),
                KeywordToken.DeepClone(),
                NameToken.DeepClone(),
                EqualsToken.DeepClone(),
                (ExpressionNode)Initializer.InternalDeepClone(),
                SemicolonToken.DeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            if (VisibilityKeywordToken != null)
                yield return VisibilityKeywordToken;

            yield return KeywordToken;

            yield return NameToken;

            yield return EqualsToken;

            yield return SemicolonToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            foreach (var child in Attributes)
                yield return child;

            yield return Initializer;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class FunctionDeclarationNode : NamedDeclarationNode
    {
        public override SyntaxNodeList<AttributeNode> Attributes { get; }

        public override SyntaxToken? VisibilityKeywordToken { get; }

        public override SyntaxToken KeywordToken { get; }

        public override SyntaxToken NameToken { get; }

        public FunctionParameterListNode ParameterList { get; }

        public BlockExpressionNode Body { get; }

        public override bool HasTokens => true;

        public override bool HasChildren => true;

        internal FunctionDeclarationNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            SyntaxNodeList<AttributeNode> attributes,
            SyntaxToken? visibilityKeywordToken,
            SyntaxToken keywordToken,
            SyntaxToken nameToken,
            FunctionParameterListNode parameterList,
            BlockExpressionNode body)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                attributes,
                visibilityKeywordToken,
                keywordToken,
                nameToken,
                parameterList,
                body)
        {
        }

        FunctionDeclarationNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            SyntaxNodeList<AttributeNode> attributes,
            SyntaxToken? visibilityKeywordToken,
            SyntaxToken keywordToken,
            SyntaxToken nameToken,
            FunctionParameterListNode parameterList,
            BlockExpressionNode body)
            : base(skipped, diagnostics, annotations)
        {
            Attributes = attributes;
            foreach (var child in attributes)
                child.Parent = this;

            VisibilityKeywordToken = visibilityKeywordToken;
            if (visibilityKeywordToken != null)
                visibilityKeywordToken.Parent = this;

            KeywordToken = keywordToken;
            keywordToken.Parent = this;

            NameToken = nameToken;
            nameToken.Parent = this;

            ParameterList = parameterList;
            parameterList.Parent = this;

            Body = body;
            body.Parent = this;
        }

        public FunctionDeclarationNode DeepClone()
        {
            return new FunctionDeclarationNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                Attributes.DeepClone(),
                VisibilityKeywordToken?.DeepClone(),
                KeywordToken.DeepClone(),
                NameToken.DeepClone(),
                (FunctionParameterListNode)ParameterList.InternalDeepClone(),
                (BlockExpressionNode)Body.InternalDeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            if (VisibilityKeywordToken != null)
                yield return VisibilityKeywordToken;

            yield return KeywordToken;

            yield return NameToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            foreach (var child in Attributes)
                yield return child;

            yield return ParameterList;

            yield return Body;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class FunctionParameterListNode : SyntaxNode
    {
        public SyntaxToken OpenParenToken { get; }

        public SeparatedSyntaxNodeList<FunctionParameterNode> Parameters { get; }

        public SyntaxToken CloseParenToken { get; }

        public override bool HasTokens => true;

        public override bool HasChildren
        {
            get
            {
                if (Parameters.Nodes.Count != 0)
                    return true;

                return false;
            }
        }

        internal FunctionParameterListNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            SyntaxToken openParenToken,
            SeparatedSyntaxNodeList<FunctionParameterNode> parameters,
            SyntaxToken closeParenToken)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                openParenToken,
                parameters,
                closeParenToken)
        {
        }

        FunctionParameterListNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            SyntaxToken openParenToken,
            SeparatedSyntaxNodeList<FunctionParameterNode> parameters,
            SyntaxToken closeParenToken)
            : base(skipped, diagnostics, annotations)
        {
            OpenParenToken = openParenToken;
            openParenToken.Parent = this;

            Parameters = parameters;
            foreach (var child in parameters.Nodes)
                child.Parent = this;
            foreach (var child in parameters.Separators)
                child.Parent = this;

            CloseParenToken = closeParenToken;
            closeParenToken.Parent = this;
        }

        public FunctionParameterListNode DeepClone()
        {
            return new FunctionParameterListNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                OpenParenToken.DeepClone(),
                Parameters.DeepClone(),
                CloseParenToken.DeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            yield return OpenParenToken;

            foreach (var token in Parameters.Separators)
                yield return token;

            yield return CloseParenToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            foreach (var child in Parameters.Nodes)
                yield return child;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class FunctionParameterNode : SyntaxNode
    {
        public SyntaxToken? DotDotToken { get; }

        public SyntaxNodeList<AttributeNode> Attributes { get; }

        public SyntaxToken NameToken { get; }

        public override bool HasTokens => true;

        public override bool HasChildren
        {
            get
            {
                if (Attributes.Count != 0)
                    return true;

                return false;
            }
        }

        internal FunctionParameterNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            SyntaxToken? dotDotToken,
            SyntaxNodeList<AttributeNode> attributes,
            SyntaxToken nameToken)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                dotDotToken,
                attributes,
                nameToken)
        {
        }

        FunctionParameterNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            SyntaxToken? dotDotToken,
            SyntaxNodeList<AttributeNode> attributes,
            SyntaxToken nameToken)
            : base(skipped, diagnostics, annotations)
        {
            DotDotToken = dotDotToken;
            if (dotDotToken != null)
                dotDotToken.Parent = this;

            Attributes = attributes;
            foreach (var child in attributes)
                child.Parent = this;

            NameToken = nameToken;
            nameToken.Parent = this;
        }

        public FunctionParameterNode DeepClone()
        {
            return new FunctionParameterNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                DotDotToken?.DeepClone(),
                Attributes.DeepClone(),
                NameToken.DeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            if (DotDotToken != null)
                yield return DotDotToken;

            yield return NameToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            foreach (var child in Attributes)
                yield return child;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class ExternalDeclarationNode : NamedDeclarationNode
    {
        public override SyntaxNodeList<AttributeNode> Attributes { get; }

        public override SyntaxToken? VisibilityKeywordToken { get; }

        public override SyntaxToken KeywordToken { get; }

        public override SyntaxToken NameToken { get; }

        public FunctionParameterListNode ParameterList { get; }

        public SyntaxToken SemicolonToken { get; }

        public override bool HasTokens => true;

        public override bool HasChildren => true;

        internal ExternalDeclarationNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            SyntaxNodeList<AttributeNode> attributes,
            SyntaxToken? visibilityKeywordToken,
            SyntaxToken keywordToken,
            SyntaxToken nameToken,
            FunctionParameterListNode parameterList,
            SyntaxToken semicolonToken)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                attributes,
                visibilityKeywordToken,
                keywordToken,
                nameToken,
                parameterList,
                semicolonToken)
        {
        }

        ExternalDeclarationNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            SyntaxNodeList<AttributeNode> attributes,
            SyntaxToken? visibilityKeywordToken,
            SyntaxToken keywordToken,
            SyntaxToken nameToken,
            FunctionParameterListNode parameterList,
            SyntaxToken semicolonToken)
            : base(skipped, diagnostics, annotations)
        {
            Attributes = attributes;
            foreach (var child in attributes)
                child.Parent = this;

            VisibilityKeywordToken = visibilityKeywordToken;
            if (visibilityKeywordToken != null)
                visibilityKeywordToken.Parent = this;

            KeywordToken = keywordToken;
            keywordToken.Parent = this;

            NameToken = nameToken;
            nameToken.Parent = this;

            ParameterList = parameterList;
            parameterList.Parent = this;

            SemicolonToken = semicolonToken;
            semicolonToken.Parent = this;
        }

        public ExternalDeclarationNode DeepClone()
        {
            return new ExternalDeclarationNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                Attributes.DeepClone(),
                VisibilityKeywordToken?.DeepClone(),
                KeywordToken.DeepClone(),
                NameToken.DeepClone(),
                (FunctionParameterListNode)ParameterList.InternalDeepClone(),
                SemicolonToken.DeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            if (VisibilityKeywordToken != null)
                yield return VisibilityKeywordToken;

            yield return KeywordToken;

            yield return NameToken;

            yield return SemicolonToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            foreach (var child in Attributes)
                yield return child;

            yield return ParameterList;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public abstract class StatementNode : SyntaxNode
    {
        public abstract SyntaxToken SemicolonToken { get; }

        private protected StatementNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations)
                : base(skipped, diagnostics, annotations)
        {
        }
    }

    public sealed class LetStatementNode : StatementNode
    {
        public SyntaxToken LetKeywordToken { get; }

        public PatternNode Pattern { get; }

        public SyntaxToken EqualsToken { get; }

        public ExpressionNode Initializer { get; }

        public override SyntaxToken SemicolonToken { get; }

        public override bool HasTokens => true;

        public override bool HasChildren => true;

        internal LetStatementNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            SyntaxToken letKeywordToken,
            PatternNode pattern,
            SyntaxToken equalsToken,
            ExpressionNode initializer,
            SyntaxToken semicolonToken)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                letKeywordToken,
                pattern,
                equalsToken,
                initializer,
                semicolonToken)
        {
        }

        LetStatementNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            SyntaxToken letKeywordToken,
            PatternNode pattern,
            SyntaxToken equalsToken,
            ExpressionNode initializer,
            SyntaxToken semicolonToken)
            : base(skipped, diagnostics, annotations)
        {
            LetKeywordToken = letKeywordToken;
            letKeywordToken.Parent = this;

            Pattern = pattern;
            pattern.Parent = this;

            EqualsToken = equalsToken;
            equalsToken.Parent = this;

            Initializer = initializer;
            initializer.Parent = this;

            SemicolonToken = semicolonToken;
            semicolonToken.Parent = this;
        }

        public LetStatementNode DeepClone()
        {
            return new LetStatementNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                LetKeywordToken.DeepClone(),
                (PatternNode)Pattern.InternalDeepClone(),
                EqualsToken.DeepClone(),
                (ExpressionNode)Initializer.InternalDeepClone(),
                SemicolonToken.DeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            yield return LetKeywordToken;

            yield return EqualsToken;

            yield return SemicolonToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            yield return Pattern;

            yield return Initializer;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class UseStatementNode : StatementNode
    {
        public SyntaxToken UseKeywordToken { get; }

        public PatternNode Pattern { get; }

        public SyntaxToken EqualsToken { get; }

        public ExpressionNode Initializer { get; }

        public override SyntaxToken SemicolonToken { get; }

        public override bool HasTokens => true;

        public override bool HasChildren => true;

        internal UseStatementNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            SyntaxToken useKeywordToken,
            PatternNode pattern,
            SyntaxToken equalsToken,
            ExpressionNode initializer,
            SyntaxToken semicolonToken)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                useKeywordToken,
                pattern,
                equalsToken,
                initializer,
                semicolonToken)
        {
        }

        UseStatementNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            SyntaxToken useKeywordToken,
            PatternNode pattern,
            SyntaxToken equalsToken,
            ExpressionNode initializer,
            SyntaxToken semicolonToken)
            : base(skipped, diagnostics, annotations)
        {
            UseKeywordToken = useKeywordToken;
            useKeywordToken.Parent = this;

            Pattern = pattern;
            pattern.Parent = this;

            EqualsToken = equalsToken;
            equalsToken.Parent = this;

            Initializer = initializer;
            initializer.Parent = this;

            SemicolonToken = semicolonToken;
            semicolonToken.Parent = this;
        }

        public UseStatementNode DeepClone()
        {
            return new UseStatementNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                UseKeywordToken.DeepClone(),
                (PatternNode)Pattern.InternalDeepClone(),
                EqualsToken.DeepClone(),
                (ExpressionNode)Initializer.InternalDeepClone(),
                SemicolonToken.DeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            yield return UseKeywordToken;

            yield return EqualsToken;

            yield return SemicolonToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            yield return Pattern;

            yield return Initializer;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class ExpressionStatementNode : StatementNode
    {
        public ExpressionNode Expression { get; }

        public override SyntaxToken SemicolonToken { get; }

        public override bool HasTokens => true;

        public override bool HasChildren => true;

        internal ExpressionStatementNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ExpressionNode expression,
            SyntaxToken semicolonToken)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                expression,
                semicolonToken)
        {
        }

        ExpressionStatementNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            ExpressionNode expression,
            SyntaxToken semicolonToken)
            : base(skipped, diagnostics, annotations)
        {
            Expression = expression;
            expression.Parent = this;

            SemicolonToken = semicolonToken;
            semicolonToken.Parent = this;
        }

        public ExpressionStatementNode DeepClone()
        {
            return new ExpressionStatementNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                (ExpressionNode)Expression.InternalDeepClone(),
                SemicolonToken.DeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            yield return SemicolonToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            yield return Expression;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public abstract class ExpressionNode : SyntaxNode
    {
        private protected ExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations)
                : base(skipped, diagnostics, annotations)
        {
        }
    }

    public sealed class MissingExpressionNode : ExpressionNode
    {
        public override bool HasTokens => false;

        public override bool HasChildren => false;

        internal MissingExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty)
        {
        }

        MissingExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations)
            : base(skipped, diagnostics, annotations)
        {
        }

        public MissingExpressionNode DeepClone()
        {
            return new MissingExpressionNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations);
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            return Array.Empty<SyntaxToken>();
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            return Array.Empty<SyntaxNode>();
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public abstract class PrefixExpressionNode : ExpressionNode
    {
        public abstract SyntaxToken OperatorOrKeywordToken { get; }

        public abstract ExpressionNode Operand { get; }

        private protected PrefixExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations)
                : base(skipped, diagnostics, annotations)
        {
        }
    }

    public sealed class UnaryExpressionNode : PrefixExpressionNode
    {
        public override SyntaxToken OperatorOrKeywordToken { get; }

        public override ExpressionNode Operand { get; }

        public override bool HasTokens => true;

        public override bool HasChildren => true;

        internal UnaryExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            SyntaxToken operatorOrKeywordToken,
            ExpressionNode operand)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                operatorOrKeywordToken,
                operand)
        {
        }

        UnaryExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            SyntaxToken operatorOrKeywordToken,
            ExpressionNode operand)
            : base(skipped, diagnostics, annotations)
        {
            OperatorOrKeywordToken = operatorOrKeywordToken;
            operatorOrKeywordToken.Parent = this;

            Operand = operand;
            operand.Parent = this;
        }

        public UnaryExpressionNode DeepClone()
        {
            return new UnaryExpressionNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                OperatorOrKeywordToken.DeepClone(),
                (ExpressionNode)Operand.InternalDeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            yield return OperatorOrKeywordToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            yield return Operand;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class AssertExpressionNode : PrefixExpressionNode
    {
        public override SyntaxToken OperatorOrKeywordToken { get; }

        public override ExpressionNode Operand { get; }

        public override bool HasTokens => true;

        public override bool HasChildren => true;

        internal AssertExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            SyntaxToken operatorOrKeywordToken,
            ExpressionNode operand)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                operatorOrKeywordToken,
                operand)
        {
        }

        AssertExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            SyntaxToken operatorOrKeywordToken,
            ExpressionNode operand)
            : base(skipped, diagnostics, annotations)
        {
            OperatorOrKeywordToken = operatorOrKeywordToken;
            operatorOrKeywordToken.Parent = this;

            Operand = operand;
            operand.Parent = this;
        }

        public AssertExpressionNode DeepClone()
        {
            return new AssertExpressionNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                OperatorOrKeywordToken.DeepClone(),
                (ExpressionNode)Operand.InternalDeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            yield return OperatorOrKeywordToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            yield return Operand;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public abstract class InfixExpressionNode : ExpressionNode
    {
        public abstract ExpressionNode LeftOperand { get; }

        public abstract SyntaxToken OperatorToken { get; }

        public abstract ExpressionNode RightOperand { get; }

        private protected InfixExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations)
                : base(skipped, diagnostics, annotations)
        {
        }
    }

    public sealed class SendExpressionNode : InfixExpressionNode
    {
        public override ExpressionNode LeftOperand { get; }

        public override SyntaxToken OperatorToken { get; }

        public override ExpressionNode RightOperand { get; }

        public override bool HasTokens => true;

        public override bool HasChildren => true;

        internal SendExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ExpressionNode leftOperand,
            SyntaxToken operatorToken,
            ExpressionNode rightOperand)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                leftOperand,
                operatorToken,
                rightOperand)
        {
        }

        SendExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            ExpressionNode leftOperand,
            SyntaxToken operatorToken,
            ExpressionNode rightOperand)
            : base(skipped, diagnostics, annotations)
        {
            LeftOperand = leftOperand;
            leftOperand.Parent = this;

            OperatorToken = operatorToken;
            operatorToken.Parent = this;

            RightOperand = rightOperand;
            rightOperand.Parent = this;
        }

        public SendExpressionNode DeepClone()
        {
            return new SendExpressionNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                (ExpressionNode)LeftOperand.InternalDeepClone(),
                OperatorToken.DeepClone(),
                (ExpressionNode)RightOperand.InternalDeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            yield return OperatorToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            yield return LeftOperand;

            yield return RightOperand;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class AssignExpressionNode : InfixExpressionNode
    {
        public override ExpressionNode LeftOperand { get; }

        public override SyntaxToken OperatorToken { get; }

        public override ExpressionNode RightOperand { get; }

        public override bool HasTokens => true;

        public override bool HasChildren => true;

        internal AssignExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ExpressionNode leftOperand,
            SyntaxToken operatorToken,
            ExpressionNode rightOperand)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                leftOperand,
                operatorToken,
                rightOperand)
        {
        }

        AssignExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            ExpressionNode leftOperand,
            SyntaxToken operatorToken,
            ExpressionNode rightOperand)
            : base(skipped, diagnostics, annotations)
        {
            LeftOperand = leftOperand;
            leftOperand.Parent = this;

            OperatorToken = operatorToken;
            operatorToken.Parent = this;

            RightOperand = rightOperand;
            rightOperand.Parent = this;
        }

        public AssignExpressionNode DeepClone()
        {
            return new AssignExpressionNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                (ExpressionNode)LeftOperand.InternalDeepClone(),
                OperatorToken.DeepClone(),
                (ExpressionNode)RightOperand.InternalDeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            yield return OperatorToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            yield return LeftOperand;

            yield return RightOperand;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class LogicalExpressionNode : InfixExpressionNode
    {
        public override ExpressionNode LeftOperand { get; }

        public override SyntaxToken OperatorToken { get; }

        public override ExpressionNode RightOperand { get; }

        public override bool HasTokens => true;

        public override bool HasChildren => true;

        internal LogicalExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ExpressionNode leftOperand,
            SyntaxToken operatorToken,
            ExpressionNode rightOperand)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                leftOperand,
                operatorToken,
                rightOperand)
        {
        }

        LogicalExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            ExpressionNode leftOperand,
            SyntaxToken operatorToken,
            ExpressionNode rightOperand)
            : base(skipped, diagnostics, annotations)
        {
            LeftOperand = leftOperand;
            leftOperand.Parent = this;

            OperatorToken = operatorToken;
            operatorToken.Parent = this;

            RightOperand = rightOperand;
            rightOperand.Parent = this;
        }

        public LogicalExpressionNode DeepClone()
        {
            return new LogicalExpressionNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                (ExpressionNode)LeftOperand.InternalDeepClone(),
                OperatorToken.DeepClone(),
                (ExpressionNode)RightOperand.InternalDeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            yield return OperatorToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            yield return LeftOperand;

            yield return RightOperand;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class RelationalExpressionNode : InfixExpressionNode
    {
        public override ExpressionNode LeftOperand { get; }

        public override SyntaxToken OperatorToken { get; }

        public override ExpressionNode RightOperand { get; }

        public override bool HasTokens => true;

        public override bool HasChildren => true;

        internal RelationalExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ExpressionNode leftOperand,
            SyntaxToken operatorToken,
            ExpressionNode rightOperand)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                leftOperand,
                operatorToken,
                rightOperand)
        {
        }

        RelationalExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            ExpressionNode leftOperand,
            SyntaxToken operatorToken,
            ExpressionNode rightOperand)
            : base(skipped, diagnostics, annotations)
        {
            LeftOperand = leftOperand;
            leftOperand.Parent = this;

            OperatorToken = operatorToken;
            operatorToken.Parent = this;

            RightOperand = rightOperand;
            rightOperand.Parent = this;
        }

        public RelationalExpressionNode DeepClone()
        {
            return new RelationalExpressionNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                (ExpressionNode)LeftOperand.InternalDeepClone(),
                OperatorToken.DeepClone(),
                (ExpressionNode)RightOperand.InternalDeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            yield return OperatorToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            yield return LeftOperand;

            yield return RightOperand;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class BitwiseExpressionNode : InfixExpressionNode
    {
        public override ExpressionNode LeftOperand { get; }

        public override SyntaxToken OperatorToken { get; }

        public override ExpressionNode RightOperand { get; }

        public override bool HasTokens => true;

        public override bool HasChildren => true;

        internal BitwiseExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ExpressionNode leftOperand,
            SyntaxToken operatorToken,
            ExpressionNode rightOperand)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                leftOperand,
                operatorToken,
                rightOperand)
        {
        }

        BitwiseExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            ExpressionNode leftOperand,
            SyntaxToken operatorToken,
            ExpressionNode rightOperand)
            : base(skipped, diagnostics, annotations)
        {
            LeftOperand = leftOperand;
            leftOperand.Parent = this;

            OperatorToken = operatorToken;
            operatorToken.Parent = this;

            RightOperand = rightOperand;
            rightOperand.Parent = this;
        }

        public BitwiseExpressionNode DeepClone()
        {
            return new BitwiseExpressionNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                (ExpressionNode)LeftOperand.InternalDeepClone(),
                OperatorToken.DeepClone(),
                (ExpressionNode)RightOperand.InternalDeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            yield return OperatorToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            yield return LeftOperand;

            yield return RightOperand;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class ShiftExpressionNode : InfixExpressionNode
    {
        public override ExpressionNode LeftOperand { get; }

        public override SyntaxToken OperatorToken { get; }

        public override ExpressionNode RightOperand { get; }

        public override bool HasTokens => true;

        public override bool HasChildren => true;

        internal ShiftExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ExpressionNode leftOperand,
            SyntaxToken operatorToken,
            ExpressionNode rightOperand)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                leftOperand,
                operatorToken,
                rightOperand)
        {
        }

        ShiftExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            ExpressionNode leftOperand,
            SyntaxToken operatorToken,
            ExpressionNode rightOperand)
            : base(skipped, diagnostics, annotations)
        {
            LeftOperand = leftOperand;
            leftOperand.Parent = this;

            OperatorToken = operatorToken;
            operatorToken.Parent = this;

            RightOperand = rightOperand;
            rightOperand.Parent = this;
        }

        public ShiftExpressionNode DeepClone()
        {
            return new ShiftExpressionNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                (ExpressionNode)LeftOperand.InternalDeepClone(),
                OperatorToken.DeepClone(),
                (ExpressionNode)RightOperand.InternalDeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            yield return OperatorToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            yield return LeftOperand;

            yield return RightOperand;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class AdditiveExpressionNode : InfixExpressionNode
    {
        public override ExpressionNode LeftOperand { get; }

        public override SyntaxToken OperatorToken { get; }

        public override ExpressionNode RightOperand { get; }

        public override bool HasTokens => true;

        public override bool HasChildren => true;

        internal AdditiveExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ExpressionNode leftOperand,
            SyntaxToken operatorToken,
            ExpressionNode rightOperand)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                leftOperand,
                operatorToken,
                rightOperand)
        {
        }

        AdditiveExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            ExpressionNode leftOperand,
            SyntaxToken operatorToken,
            ExpressionNode rightOperand)
            : base(skipped, diagnostics, annotations)
        {
            LeftOperand = leftOperand;
            leftOperand.Parent = this;

            OperatorToken = operatorToken;
            operatorToken.Parent = this;

            RightOperand = rightOperand;
            rightOperand.Parent = this;
        }

        public AdditiveExpressionNode DeepClone()
        {
            return new AdditiveExpressionNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                (ExpressionNode)LeftOperand.InternalDeepClone(),
                OperatorToken.DeepClone(),
                (ExpressionNode)RightOperand.InternalDeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            yield return OperatorToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            yield return LeftOperand;

            yield return RightOperand;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class MultiplicativeExpressionNode : InfixExpressionNode
    {
        public override ExpressionNode LeftOperand { get; }

        public override SyntaxToken OperatorToken { get; }

        public override ExpressionNode RightOperand { get; }

        public override bool HasTokens => true;

        public override bool HasChildren => true;

        internal MultiplicativeExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ExpressionNode leftOperand,
            SyntaxToken operatorToken,
            ExpressionNode rightOperand)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                leftOperand,
                operatorToken,
                rightOperand)
        {
        }

        MultiplicativeExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            ExpressionNode leftOperand,
            SyntaxToken operatorToken,
            ExpressionNode rightOperand)
            : base(skipped, diagnostics, annotations)
        {
            LeftOperand = leftOperand;
            leftOperand.Parent = this;

            OperatorToken = operatorToken;
            operatorToken.Parent = this;

            RightOperand = rightOperand;
            rightOperand.Parent = this;
        }

        public MultiplicativeExpressionNode DeepClone()
        {
            return new MultiplicativeExpressionNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                (ExpressionNode)LeftOperand.InternalDeepClone(),
                OperatorToken.DeepClone(),
                (ExpressionNode)RightOperand.InternalDeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            yield return OperatorToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            yield return LeftOperand;

            yield return RightOperand;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public abstract class PostfixExpressionNode : ExpressionNode
    {
        public abstract ExpressionNode Subject { get; }

        private protected PostfixExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations)
                : base(skipped, diagnostics, annotations)
        {
        }
    }

    public sealed class CallExpressionNode : PostfixExpressionNode
    {
        public override ExpressionNode Subject { get; }

        public ArgumentListNode ArgumentList { get; }

        public CallTryNode? Try { get; }

        public override bool HasTokens => false;

        public override bool HasChildren => true;

        internal CallExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ExpressionNode subject,
            ArgumentListNode argumentList,
            CallTryNode? @try)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                subject,
                argumentList,
                @try)
        {
        }

        CallExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            ExpressionNode subject,
            ArgumentListNode argumentList,
            CallTryNode? @try)
            : base(skipped, diagnostics, annotations)
        {
            Subject = subject;
            subject.Parent = this;

            ArgumentList = argumentList;
            argumentList.Parent = this;

            Try = @try;
            if (@try != null)
                @try.Parent = this;
        }

        public CallExpressionNode DeepClone()
        {
            return new CallExpressionNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                (ExpressionNode)Subject.InternalDeepClone(),
                (ArgumentListNode)ArgumentList.InternalDeepClone(),
                (CallTryNode?)Try?.InternalDeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            return Array.Empty<SyntaxToken>();
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            yield return Subject;

            yield return ArgumentList;

            if (Try != null)
                yield return Try;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class ArgumentListNode : SyntaxNode
    {
        public SyntaxToken OpenParenToken { get; }

        public SeparatedSyntaxNodeList<ArgumentNode> Arguments { get; }

        public SyntaxToken CloseParenToken { get; }

        public override bool HasTokens => true;

        public override bool HasChildren
        {
            get
            {
                if (Arguments.Nodes.Count != 0)
                    return true;

                return false;
            }
        }

        internal ArgumentListNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            SyntaxToken openParenToken,
            SeparatedSyntaxNodeList<ArgumentNode> arguments,
            SyntaxToken closeParenToken)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                openParenToken,
                arguments,
                closeParenToken)
        {
        }

        ArgumentListNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            SyntaxToken openParenToken,
            SeparatedSyntaxNodeList<ArgumentNode> arguments,
            SyntaxToken closeParenToken)
            : base(skipped, diagnostics, annotations)
        {
            OpenParenToken = openParenToken;
            openParenToken.Parent = this;

            Arguments = arguments;
            foreach (var child in arguments.Nodes)
                child.Parent = this;
            foreach (var child in arguments.Separators)
                child.Parent = this;

            CloseParenToken = closeParenToken;
            closeParenToken.Parent = this;
        }

        public ArgumentListNode DeepClone()
        {
            return new ArgumentListNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                OpenParenToken.DeepClone(),
                Arguments.DeepClone(),
                CloseParenToken.DeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            yield return OpenParenToken;

            foreach (var token in Arguments.Separators)
                yield return token;

            yield return CloseParenToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            foreach (var child in Arguments.Nodes)
                yield return child;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class ArgumentNode : SyntaxNode
    {
        public SyntaxToken? DotDotToken { get; }

        public ExpressionNode Value { get; }

        public override bool HasTokens
        {
            get
            {
                if (DotDotToken != null)
                    return true;

                return false;
            }
        }

        public override bool HasChildren => true;

        internal ArgumentNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            SyntaxToken? dotDotToken,
            ExpressionNode value)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                dotDotToken,
                value)
        {
        }

        ArgumentNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            SyntaxToken? dotDotToken,
            ExpressionNode value)
            : base(skipped, diagnostics, annotations)
        {
            DotDotToken = dotDotToken;
            if (dotDotToken != null)
                dotDotToken.Parent = this;

            Value = value;
            value.Parent = this;
        }

        public ArgumentNode DeepClone()
        {
            return new ArgumentNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                DotDotToken?.DeepClone(),
                (ExpressionNode)Value.InternalDeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            if (DotDotToken != null)
                yield return DotDotToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            yield return Value;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class CallTryNode : SyntaxNode
    {
        public SyntaxToken QuestionToken { get; }

        public CallTryCatchNode? Catch { get; }

        public override bool HasTokens => true;

        public override bool HasChildren
        {
            get
            {
                if (Catch != null)
                    return true;

                return false;
            }
        }

        internal CallTryNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            SyntaxToken questionToken,
            CallTryCatchNode? @catch)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                questionToken,
                @catch)
        {
        }

        CallTryNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            SyntaxToken questionToken,
            CallTryCatchNode? @catch)
            : base(skipped, diagnostics, annotations)
        {
            QuestionToken = questionToken;
            questionToken.Parent = this;

            Catch = @catch;
            if (@catch != null)
                @catch.Parent = this;
        }

        public CallTryNode DeepClone()
        {
            return new CallTryNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                QuestionToken.DeepClone(),
                (CallTryCatchNode?)Catch?.InternalDeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            yield return QuestionToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            if (Catch != null)
                yield return Catch;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class CallTryCatchNode : SyntaxNode
    {
        public SyntaxToken CatchKeywordToken { get; }

        public SyntaxToken OpenBraceToken { get; }

        public SyntaxNodeList<PatternArmNode> Arms { get; }

        public SyntaxToken CloseBraceToken { get; }

        public override bool HasTokens => true;

        public override bool HasChildren
        {
            get
            {
                if (Arms.Count != 0)
                    return true;

                return false;
            }
        }

        internal CallTryCatchNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            SyntaxToken catchKeywordToken,
            SyntaxToken openBraceToken,
            SyntaxNodeList<PatternArmNode> arms,
            SyntaxToken closeBraceToken)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                catchKeywordToken,
                openBraceToken,
                arms,
                closeBraceToken)
        {
        }

        CallTryCatchNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            SyntaxToken catchKeywordToken,
            SyntaxToken openBraceToken,
            SyntaxNodeList<PatternArmNode> arms,
            SyntaxToken closeBraceToken)
            : base(skipped, diagnostics, annotations)
        {
            CatchKeywordToken = catchKeywordToken;
            catchKeywordToken.Parent = this;

            OpenBraceToken = openBraceToken;
            openBraceToken.Parent = this;

            Arms = arms;
            foreach (var child in arms)
                child.Parent = this;

            CloseBraceToken = closeBraceToken;
            closeBraceToken.Parent = this;
        }

        public CallTryCatchNode DeepClone()
        {
            return new CallTryCatchNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                CatchKeywordToken.DeepClone(),
                OpenBraceToken.DeepClone(),
                Arms.DeepClone(),
                CloseBraceToken.DeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            yield return CatchKeywordToken;

            yield return OpenBraceToken;

            yield return CloseBraceToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            foreach (var child in Arms)
                yield return child;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class PatternArmNode : SyntaxNode
    {
        public PatternNode Pattern { get; }

        public PatternArmGuardNode? Guard { get; }

        public SyntaxToken ArrowToken { get; }

        public ExpressionNode Body { get; }

        public SyntaxToken SemicolonToken { get; }

        public override bool HasTokens => true;

        public override bool HasChildren => true;

        internal PatternArmNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            PatternNode pattern,
            PatternArmGuardNode? guard,
            SyntaxToken arrowToken,
            ExpressionNode body,
            SyntaxToken semicolonToken)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                pattern,
                guard,
                arrowToken,
                body,
                semicolonToken)
        {
        }

        PatternArmNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            PatternNode pattern,
            PatternArmGuardNode? guard,
            SyntaxToken arrowToken,
            ExpressionNode body,
            SyntaxToken semicolonToken)
            : base(skipped, diagnostics, annotations)
        {
            Pattern = pattern;
            pattern.Parent = this;

            Guard = guard;
            if (guard != null)
                guard.Parent = this;

            ArrowToken = arrowToken;
            arrowToken.Parent = this;

            Body = body;
            body.Parent = this;

            SemicolonToken = semicolonToken;
            semicolonToken.Parent = this;
        }

        public PatternArmNode DeepClone()
        {
            return new PatternArmNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                (PatternNode)Pattern.InternalDeepClone(),
                (PatternArmGuardNode?)Guard?.InternalDeepClone(),
                ArrowToken.DeepClone(),
                (ExpressionNode)Body.InternalDeepClone(),
                SemicolonToken.DeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            yield return ArrowToken;

            yield return SemicolonToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            yield return Pattern;

            if (Guard != null)
                yield return Guard;

            yield return Body;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class PatternArmGuardNode : SyntaxNode
    {
        public SyntaxToken IfKeywordToken { get; }

        public ExpressionNode Condition { get; }

        public override bool HasTokens => true;

        public override bool HasChildren => true;

        internal PatternArmGuardNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            SyntaxToken ifKeywordToken,
            ExpressionNode condition)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                ifKeywordToken,
                condition)
        {
        }

        PatternArmGuardNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            SyntaxToken ifKeywordToken,
            ExpressionNode condition)
            : base(skipped, diagnostics, annotations)
        {
            IfKeywordToken = ifKeywordToken;
            ifKeywordToken.Parent = this;

            Condition = condition;
            condition.Parent = this;
        }

        public PatternArmGuardNode DeepClone()
        {
            return new PatternArmGuardNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                IfKeywordToken.DeepClone(),
                (ExpressionNode)Condition.InternalDeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            yield return IfKeywordToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            yield return Condition;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class MethodCallExpressionNode : PostfixExpressionNode
    {
        public override ExpressionNode Subject { get; }

        public SyntaxToken ArrowToken { get; }

        public SyntaxToken NameToken { get; }

        public ArgumentListNode ArgumentList { get; }

        public CallTryNode? Try { get; }

        public override bool HasTokens => true;

        public override bool HasChildren => true;

        internal MethodCallExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ExpressionNode subject,
            SyntaxToken arrowToken,
            SyntaxToken nameToken,
            ArgumentListNode argumentList,
            CallTryNode? @try)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                subject,
                arrowToken,
                nameToken,
                argumentList,
                @try)
        {
        }

        MethodCallExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            ExpressionNode subject,
            SyntaxToken arrowToken,
            SyntaxToken nameToken,
            ArgumentListNode argumentList,
            CallTryNode? @try)
            : base(skipped, diagnostics, annotations)
        {
            Subject = subject;
            subject.Parent = this;

            ArrowToken = arrowToken;
            arrowToken.Parent = this;

            NameToken = nameToken;
            nameToken.Parent = this;

            ArgumentList = argumentList;
            argumentList.Parent = this;

            Try = @try;
            if (@try != null)
                @try.Parent = this;
        }

        public MethodCallExpressionNode DeepClone()
        {
            return new MethodCallExpressionNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                (ExpressionNode)Subject.InternalDeepClone(),
                ArrowToken.DeepClone(),
                NameToken.DeepClone(),
                (ArgumentListNode)ArgumentList.InternalDeepClone(),
                (CallTryNode?)Try?.InternalDeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            yield return ArrowToken;

            yield return NameToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            yield return Subject;

            yield return ArgumentList;

            if (Try != null)
                yield return Try;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class IndexExpressionNode : PostfixExpressionNode
    {
        public override ExpressionNode Subject { get; }

        public IndexListNode IndexList { get; }

        public override bool HasTokens => false;

        public override bool HasChildren => true;

        internal IndexExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ExpressionNode subject,
            IndexListNode indexList)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                subject,
                indexList)
        {
        }

        IndexExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            ExpressionNode subject,
            IndexListNode indexList)
            : base(skipped, diagnostics, annotations)
        {
            Subject = subject;
            subject.Parent = this;

            IndexList = indexList;
            indexList.Parent = this;
        }

        public IndexExpressionNode DeepClone()
        {
            return new IndexExpressionNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                (ExpressionNode)Subject.InternalDeepClone(),
                (IndexListNode)IndexList.InternalDeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            return Array.Empty<SyntaxToken>();
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            yield return Subject;

            yield return IndexList;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class IndexListNode : SyntaxNode
    {
        public SyntaxToken OpenBracketToken { get; }

        public SeparatedSyntaxNodeList<IndexNode> Indices { get; }

        public SyntaxToken CloseBracketToken { get; }

        public override bool HasTokens => true;

        public override bool HasChildren
        {
            get
            {
                if (Indices.Nodes.Count != 0)
                    return true;

                return false;
            }
        }

        internal IndexListNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            SyntaxToken openBracketToken,
            SeparatedSyntaxNodeList<IndexNode> indices,
            SyntaxToken closeBracketToken)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                openBracketToken,
                indices,
                closeBracketToken)
        {
        }

        IndexListNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            SyntaxToken openBracketToken,
            SeparatedSyntaxNodeList<IndexNode> indices,
            SyntaxToken closeBracketToken)
            : base(skipped, diagnostics, annotations)
        {
            OpenBracketToken = openBracketToken;
            openBracketToken.Parent = this;

            Indices = indices;
            foreach (var child in indices.Nodes)
                child.Parent = this;
            foreach (var child in indices.Separators)
                child.Parent = this;

            CloseBracketToken = closeBracketToken;
            closeBracketToken.Parent = this;
        }

        public IndexListNode DeepClone()
        {
            return new IndexListNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                OpenBracketToken.DeepClone(),
                Indices.DeepClone(),
                CloseBracketToken.DeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            yield return OpenBracketToken;

            foreach (var token in Indices.Separators)
                yield return token;

            yield return CloseBracketToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            foreach (var child in Indices.Nodes)
                yield return child;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class IndexNode : SyntaxNode
    {
        public SyntaxToken? DotDotToken { get; }

        public ExpressionNode Value { get; }

        public override bool HasTokens
        {
            get
            {
                if (DotDotToken != null)
                    return true;

                return false;
            }
        }

        public override bool HasChildren => true;

        internal IndexNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            SyntaxToken? dotDotToken,
            ExpressionNode value)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                dotDotToken,
                value)
        {
        }

        IndexNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            SyntaxToken? dotDotToken,
            ExpressionNode value)
            : base(skipped, diagnostics, annotations)
        {
            DotDotToken = dotDotToken;
            if (dotDotToken != null)
                dotDotToken.Parent = this;

            Value = value;
            value.Parent = this;
        }

        public IndexNode DeepClone()
        {
            return new IndexNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                DotDotToken?.DeepClone(),
                (ExpressionNode)Value.InternalDeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            if (DotDotToken != null)
                yield return DotDotToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            yield return Value;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class FieldAccessExpressionNode : PostfixExpressionNode
    {
        public override ExpressionNode Subject { get; }

        public SyntaxToken DotToken { get; }

        public SyntaxToken NameToken { get; }

        public override bool HasTokens => true;

        public override bool HasChildren => true;

        internal FieldAccessExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ExpressionNode subject,
            SyntaxToken dotToken,
            SyntaxToken nameToken)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                subject,
                dotToken,
                nameToken)
        {
        }

        FieldAccessExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            ExpressionNode subject,
            SyntaxToken dotToken,
            SyntaxToken nameToken)
            : base(skipped, diagnostics, annotations)
        {
            Subject = subject;
            subject.Parent = this;

            DotToken = dotToken;
            dotToken.Parent = this;

            NameToken = nameToken;
            nameToken.Parent = this;
        }

        public FieldAccessExpressionNode DeepClone()
        {
            return new FieldAccessExpressionNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                (ExpressionNode)Subject.InternalDeepClone(),
                DotToken.DeepClone(),
                NameToken.DeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            yield return DotToken;

            yield return NameToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            yield return Subject;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public abstract class PrimaryExpressionNode : ExpressionNode
    {
        private protected PrimaryExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations)
                : base(skipped, diagnostics, annotations)
        {
        }
    }

    public sealed class ParenthesizedExpressionNode : PrimaryExpressionNode
    {
        public SyntaxToken OpenParenToken { get; }

        public ExpressionNode Expression { get; }

        public SyntaxToken CloseParenToken { get; }

        public override bool HasTokens => true;

        public override bool HasChildren => true;

        internal ParenthesizedExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            SyntaxToken openParenToken,
            ExpressionNode expression,
            SyntaxToken closeParenToken)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                openParenToken,
                expression,
                closeParenToken)
        {
        }

        ParenthesizedExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            SyntaxToken openParenToken,
            ExpressionNode expression,
            SyntaxToken closeParenToken)
            : base(skipped, diagnostics, annotations)
        {
            OpenParenToken = openParenToken;
            openParenToken.Parent = this;

            Expression = expression;
            expression.Parent = this;

            CloseParenToken = closeParenToken;
            closeParenToken.Parent = this;
        }

        public ParenthesizedExpressionNode DeepClone()
        {
            return new ParenthesizedExpressionNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                OpenParenToken.DeepClone(),
                (ExpressionNode)Expression.InternalDeepClone(),
                CloseParenToken.DeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            yield return OpenParenToken;

            yield return CloseParenToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            yield return Expression;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class IdentifierExpressionNode : PrimaryExpressionNode
    {
        public SyntaxToken IdentifierToken { get; }

        public override bool HasTokens => true;

        public override bool HasChildren => false;

        internal IdentifierExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            SyntaxToken identifierToken)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                identifierToken)
        {
        }

        IdentifierExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            SyntaxToken identifierToken)
            : base(skipped, diagnostics, annotations)
        {
            IdentifierToken = identifierToken;
            identifierToken.Parent = this;
        }

        public IdentifierExpressionNode DeepClone()
        {
            return new IdentifierExpressionNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                IdentifierToken.DeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            yield return IdentifierToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            return Array.Empty<SyntaxNode>();
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class LiteralExpressionNode : PrimaryExpressionNode
    {
        public SyntaxToken ValueToken { get; }

        public override bool HasTokens => true;

        public override bool HasChildren => false;

        internal LiteralExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            SyntaxToken valueToken)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                valueToken)
        {
        }

        LiteralExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            SyntaxToken valueToken)
            : base(skipped, diagnostics, annotations)
        {
            ValueToken = valueToken;
            valueToken.Parent = this;
        }

        public LiteralExpressionNode DeepClone()
        {
            return new LiteralExpressionNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                ValueToken.DeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            yield return ValueToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            return Array.Empty<SyntaxNode>();
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class LambdaExpressionNode : PrimaryExpressionNode
    {
        public SyntaxToken FnKeywordToken { get; }

        public LambdaParameterListNode ParameterList { get; }

        public SyntaxToken ArrowToken { get; }

        public ExpressionNode Body { get; }

        public override bool HasTokens => true;

        public override bool HasChildren => true;

        internal LambdaExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            SyntaxToken fnKeywordToken,
            LambdaParameterListNode parameterList,
            SyntaxToken arrowToken,
            ExpressionNode body)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                fnKeywordToken,
                parameterList,
                arrowToken,
                body)
        {
        }

        LambdaExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            SyntaxToken fnKeywordToken,
            LambdaParameterListNode parameterList,
            SyntaxToken arrowToken,
            ExpressionNode body)
            : base(skipped, diagnostics, annotations)
        {
            FnKeywordToken = fnKeywordToken;
            fnKeywordToken.Parent = this;

            ParameterList = parameterList;
            parameterList.Parent = this;

            ArrowToken = arrowToken;
            arrowToken.Parent = this;

            Body = body;
            body.Parent = this;
        }

        public LambdaExpressionNode DeepClone()
        {
            return new LambdaExpressionNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                FnKeywordToken.DeepClone(),
                (LambdaParameterListNode)ParameterList.InternalDeepClone(),
                ArrowToken.DeepClone(),
                (ExpressionNode)Body.InternalDeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            yield return FnKeywordToken;

            yield return ArrowToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            yield return ParameterList;

            yield return Body;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class LambdaParameterListNode : SyntaxNode
    {
        public SyntaxToken OpenParenToken { get; }

        public SeparatedSyntaxNodeList<LambdaParameterNode> Parameters { get; }

        public SyntaxToken CloseParenToken { get; }

        public override bool HasTokens => true;

        public override bool HasChildren
        {
            get
            {
                if (Parameters.Nodes.Count != 0)
                    return true;

                return false;
            }
        }

        internal LambdaParameterListNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            SyntaxToken openParenToken,
            SeparatedSyntaxNodeList<LambdaParameterNode> parameters,
            SyntaxToken closeParenToken)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                openParenToken,
                parameters,
                closeParenToken)
        {
        }

        LambdaParameterListNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            SyntaxToken openParenToken,
            SeparatedSyntaxNodeList<LambdaParameterNode> parameters,
            SyntaxToken closeParenToken)
            : base(skipped, diagnostics, annotations)
        {
            OpenParenToken = openParenToken;
            openParenToken.Parent = this;

            Parameters = parameters;
            foreach (var child in parameters.Nodes)
                child.Parent = this;
            foreach (var child in parameters.Separators)
                child.Parent = this;

            CloseParenToken = closeParenToken;
            closeParenToken.Parent = this;
        }

        public LambdaParameterListNode DeepClone()
        {
            return new LambdaParameterListNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                OpenParenToken.DeepClone(),
                Parameters.DeepClone(),
                CloseParenToken.DeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            yield return OpenParenToken;

            foreach (var token in Parameters.Separators)
                yield return token;

            yield return CloseParenToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            foreach (var child in Parameters.Nodes)
                yield return child;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class LambdaParameterNode : SyntaxNode
    {
        public SyntaxToken? DotDotToken { get; }

        public SyntaxToken NameToken { get; }

        public override bool HasTokens => true;

        public override bool HasChildren => false;

        internal LambdaParameterNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            SyntaxToken? dotDotToken,
            SyntaxToken nameToken)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                dotDotToken,
                nameToken)
        {
        }

        LambdaParameterNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            SyntaxToken? dotDotToken,
            SyntaxToken nameToken)
            : base(skipped, diagnostics, annotations)
        {
            DotDotToken = dotDotToken;
            if (dotDotToken != null)
                dotDotToken.Parent = this;

            NameToken = nameToken;
            nameToken.Parent = this;
        }

        public LambdaParameterNode DeepClone()
        {
            return new LambdaParameterNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                DotDotToken?.DeepClone(),
                NameToken.DeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            if (DotDotToken != null)
                yield return DotDotToken;

            yield return NameToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            return Array.Empty<SyntaxNode>();
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class ModuleExpressionNode : PrimaryExpressionNode
    {
        public ModulePathNode Path { get; }

        public override bool HasTokens => false;

        public override bool HasChildren => true;

        internal ModuleExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ModulePathNode path)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                path)
        {
        }

        ModuleExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            ModulePathNode path)
            : base(skipped, diagnostics, annotations)
        {
            Path = path;
            path.Parent = this;
        }

        public ModuleExpressionNode DeepClone()
        {
            return new ModuleExpressionNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                (ModulePathNode)Path.InternalDeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            return Array.Empty<SyntaxToken>();
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            yield return Path;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class RecordExpressionNode : PrimaryExpressionNode
    {
        public SyntaxToken RecKeywordToken { get; }

        public SyntaxToken? NameToken { get; }

        public SyntaxToken OpenBraceToken { get; }

        public SeparatedSyntaxNodeList<ExpressionFieldNode> Fields { get; }

        public SyntaxToken CloseBraceToken { get; }

        public override bool HasTokens => true;

        public override bool HasChildren
        {
            get
            {
                if (Fields.Nodes.Count != 0)
                    return true;

                return false;
            }
        }

        internal RecordExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            SyntaxToken recKeywordToken,
            SyntaxToken? nameToken,
            SyntaxToken openBraceToken,
            SeparatedSyntaxNodeList<ExpressionFieldNode> fields,
            SyntaxToken closeBraceToken)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                recKeywordToken,
                nameToken,
                openBraceToken,
                fields,
                closeBraceToken)
        {
        }

        RecordExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            SyntaxToken recKeywordToken,
            SyntaxToken? nameToken,
            SyntaxToken openBraceToken,
            SeparatedSyntaxNodeList<ExpressionFieldNode> fields,
            SyntaxToken closeBraceToken)
            : base(skipped, diagnostics, annotations)
        {
            RecKeywordToken = recKeywordToken;
            recKeywordToken.Parent = this;

            NameToken = nameToken;
            if (nameToken != null)
                nameToken.Parent = this;

            OpenBraceToken = openBraceToken;
            openBraceToken.Parent = this;

            Fields = fields;
            foreach (var child in fields.Nodes)
                child.Parent = this;
            foreach (var child in fields.Separators)
                child.Parent = this;

            CloseBraceToken = closeBraceToken;
            closeBraceToken.Parent = this;
        }

        public RecordExpressionNode DeepClone()
        {
            return new RecordExpressionNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                RecKeywordToken.DeepClone(),
                NameToken?.DeepClone(),
                OpenBraceToken.DeepClone(),
                Fields.DeepClone(),
                CloseBraceToken.DeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            yield return RecKeywordToken;

            if (NameToken != null)
                yield return NameToken;

            yield return OpenBraceToken;

            foreach (var token in Fields.Separators)
                yield return token;

            yield return CloseBraceToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            foreach (var child in Fields.Nodes)
                yield return child;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class ExpressionFieldNode : SyntaxNode
    {
        public SyntaxToken? MutKeywordToken { get; }

        public SyntaxToken NameToken { get; }

        public SyntaxToken EqualsToken { get; }

        public ExpressionNode Value { get; }

        public override bool HasTokens => true;

        public override bool HasChildren => true;

        internal ExpressionFieldNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            SyntaxToken? mutKeywordToken,
            SyntaxToken nameToken,
            SyntaxToken equalsToken,
            ExpressionNode value)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                mutKeywordToken,
                nameToken,
                equalsToken,
                value)
        {
        }

        ExpressionFieldNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            SyntaxToken? mutKeywordToken,
            SyntaxToken nameToken,
            SyntaxToken equalsToken,
            ExpressionNode value)
            : base(skipped, diagnostics, annotations)
        {
            MutKeywordToken = mutKeywordToken;
            if (mutKeywordToken != null)
                mutKeywordToken.Parent = this;

            NameToken = nameToken;
            nameToken.Parent = this;

            EqualsToken = equalsToken;
            equalsToken.Parent = this;

            Value = value;
            value.Parent = this;
        }

        public ExpressionFieldNode DeepClone()
        {
            return new ExpressionFieldNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                MutKeywordToken?.DeepClone(),
                NameToken.DeepClone(),
                EqualsToken.DeepClone(),
                (ExpressionNode)Value.InternalDeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            if (MutKeywordToken != null)
                yield return MutKeywordToken;

            yield return NameToken;

            yield return EqualsToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            yield return Value;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class ExceptionExpressionNode : PrimaryExpressionNode
    {
        public SyntaxToken ExcKeywordToken { get; }

        public SyntaxToken NameToken { get; }

        public SyntaxToken OpenBraceToken { get; }

        public SeparatedSyntaxNodeList<ExpressionFieldNode> Fields { get; }

        public SyntaxToken CloseBraceToken { get; }

        public override bool HasTokens => true;

        public override bool HasChildren
        {
            get
            {
                if (Fields.Nodes.Count != 0)
                    return true;

                return false;
            }
        }

        internal ExceptionExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            SyntaxToken excKeywordToken,
            SyntaxToken nameToken,
            SyntaxToken openBraceToken,
            SeparatedSyntaxNodeList<ExpressionFieldNode> fields,
            SyntaxToken closeBraceToken)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                excKeywordToken,
                nameToken,
                openBraceToken,
                fields,
                closeBraceToken)
        {
        }

        ExceptionExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            SyntaxToken excKeywordToken,
            SyntaxToken nameToken,
            SyntaxToken openBraceToken,
            SeparatedSyntaxNodeList<ExpressionFieldNode> fields,
            SyntaxToken closeBraceToken)
            : base(skipped, diagnostics, annotations)
        {
            ExcKeywordToken = excKeywordToken;
            excKeywordToken.Parent = this;

            NameToken = nameToken;
            nameToken.Parent = this;

            OpenBraceToken = openBraceToken;
            openBraceToken.Parent = this;

            Fields = fields;
            foreach (var child in fields.Nodes)
                child.Parent = this;
            foreach (var child in fields.Separators)
                child.Parent = this;

            CloseBraceToken = closeBraceToken;
            closeBraceToken.Parent = this;
        }

        public ExceptionExpressionNode DeepClone()
        {
            return new ExceptionExpressionNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                ExcKeywordToken.DeepClone(),
                NameToken.DeepClone(),
                OpenBraceToken.DeepClone(),
                Fields.DeepClone(),
                CloseBraceToken.DeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            yield return ExcKeywordToken;

            yield return NameToken;

            yield return OpenBraceToken;

            foreach (var token in Fields.Separators)
                yield return token;

            yield return CloseBraceToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            foreach (var child in Fields.Nodes)
                yield return child;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class TupleExpressionNode : PrimaryExpressionNode
    {
        public SyntaxToken OpenParenToken { get; }

        public SeparatedSyntaxNodeList<ExpressionNode> Components { get; }

        public SyntaxToken CloseParenToken { get; }

        public override bool HasTokens => true;

        public override bool HasChildren
        {
            get
            {
                if (Components.Nodes.Count != 0)
                    return true;

                return false;
            }
        }

        internal TupleExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            SyntaxToken openParenToken,
            SeparatedSyntaxNodeList<ExpressionNode> components,
            SyntaxToken closeParenToken)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                openParenToken,
                components,
                closeParenToken)
        {
        }

        TupleExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            SyntaxToken openParenToken,
            SeparatedSyntaxNodeList<ExpressionNode> components,
            SyntaxToken closeParenToken)
            : base(skipped, diagnostics, annotations)
        {
            OpenParenToken = openParenToken;
            openParenToken.Parent = this;

            Components = components;
            foreach (var child in components.Nodes)
                child.Parent = this;
            foreach (var child in components.Separators)
                child.Parent = this;

            CloseParenToken = closeParenToken;
            closeParenToken.Parent = this;
        }

        public TupleExpressionNode DeepClone()
        {
            return new TupleExpressionNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                OpenParenToken.DeepClone(),
                Components.DeepClone(),
                CloseParenToken.DeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            yield return OpenParenToken;

            foreach (var token in Components.Separators)
                yield return token;

            yield return CloseParenToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            foreach (var child in Components.Nodes)
                yield return child;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class ArrayExpressionNode : PrimaryExpressionNode
    {
        public SyntaxToken? MutKeywordToken { get; }

        public SyntaxToken OpenBracketToken { get; }

        public SeparatedSyntaxNodeList<ExpressionNode> Elements { get; }

        public SyntaxToken CloseBracketToken { get; }

        public override bool HasTokens => true;

        public override bool HasChildren
        {
            get
            {
                if (Elements.Nodes.Count != 0)
                    return true;

                return false;
            }
        }

        internal ArrayExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            SyntaxToken? mutKeywordToken,
            SyntaxToken openBracketToken,
            SeparatedSyntaxNodeList<ExpressionNode> elements,
            SyntaxToken closeBracketToken)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                mutKeywordToken,
                openBracketToken,
                elements,
                closeBracketToken)
        {
        }

        ArrayExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            SyntaxToken? mutKeywordToken,
            SyntaxToken openBracketToken,
            SeparatedSyntaxNodeList<ExpressionNode> elements,
            SyntaxToken closeBracketToken)
            : base(skipped, diagnostics, annotations)
        {
            MutKeywordToken = mutKeywordToken;
            if (mutKeywordToken != null)
                mutKeywordToken.Parent = this;

            OpenBracketToken = openBracketToken;
            openBracketToken.Parent = this;

            Elements = elements;
            foreach (var child in elements.Nodes)
                child.Parent = this;
            foreach (var child in elements.Separators)
                child.Parent = this;

            CloseBracketToken = closeBracketToken;
            closeBracketToken.Parent = this;
        }

        public ArrayExpressionNode DeepClone()
        {
            return new ArrayExpressionNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                MutKeywordToken?.DeepClone(),
                OpenBracketToken.DeepClone(),
                Elements.DeepClone(),
                CloseBracketToken.DeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            if (MutKeywordToken != null)
                yield return MutKeywordToken;

            yield return OpenBracketToken;

            foreach (var token in Elements.Separators)
                yield return token;

            yield return CloseBracketToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            foreach (var child in Elements.Nodes)
                yield return child;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class SetExpressionNode : PrimaryExpressionNode
    {
        public SyntaxToken? MutKeywordToken { get; }

        public SyntaxToken HashToken { get; }

        public SyntaxToken OpenBraceToken { get; }

        public SeparatedSyntaxNodeList<ExpressionNode> Elements { get; }

        public SyntaxToken CloseBraceToken { get; }

        public override bool HasTokens => true;

        public override bool HasChildren
        {
            get
            {
                if (Elements.Nodes.Count != 0)
                    return true;

                return false;
            }
        }

        internal SetExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            SyntaxToken? mutKeywordToken,
            SyntaxToken hashToken,
            SyntaxToken openBraceToken,
            SeparatedSyntaxNodeList<ExpressionNode> elements,
            SyntaxToken closeBraceToken)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                mutKeywordToken,
                hashToken,
                openBraceToken,
                elements,
                closeBraceToken)
        {
        }

        SetExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            SyntaxToken? mutKeywordToken,
            SyntaxToken hashToken,
            SyntaxToken openBraceToken,
            SeparatedSyntaxNodeList<ExpressionNode> elements,
            SyntaxToken closeBraceToken)
            : base(skipped, diagnostics, annotations)
        {
            MutKeywordToken = mutKeywordToken;
            if (mutKeywordToken != null)
                mutKeywordToken.Parent = this;

            HashToken = hashToken;
            hashToken.Parent = this;

            OpenBraceToken = openBraceToken;
            openBraceToken.Parent = this;

            Elements = elements;
            foreach (var child in elements.Nodes)
                child.Parent = this;
            foreach (var child in elements.Separators)
                child.Parent = this;

            CloseBraceToken = closeBraceToken;
            closeBraceToken.Parent = this;
        }

        public SetExpressionNode DeepClone()
        {
            return new SetExpressionNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                MutKeywordToken?.DeepClone(),
                HashToken.DeepClone(),
                OpenBraceToken.DeepClone(),
                Elements.DeepClone(),
                CloseBraceToken.DeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            if (MutKeywordToken != null)
                yield return MutKeywordToken;

            yield return HashToken;

            yield return OpenBraceToken;

            foreach (var token in Elements.Separators)
                yield return token;

            yield return CloseBraceToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            foreach (var child in Elements.Nodes)
                yield return child;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class MapExpressionNode : PrimaryExpressionNode
    {
        public SyntaxToken? MutKeywordToken { get; }

        public SyntaxToken HashToken { get; }

        public SyntaxToken OpenBracketToken { get; }

        public SeparatedSyntaxNodeList<MapExpressionPairNode> Pairs { get; }

        public SyntaxToken CloseBracketToken { get; }

        public override bool HasTokens => true;

        public override bool HasChildren
        {
            get
            {
                if (Pairs.Nodes.Count != 0)
                    return true;

                return false;
            }
        }

        internal MapExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            SyntaxToken? mutKeywordToken,
            SyntaxToken hashToken,
            SyntaxToken openBracketToken,
            SeparatedSyntaxNodeList<MapExpressionPairNode> pairs,
            SyntaxToken closeBracketToken)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                mutKeywordToken,
                hashToken,
                openBracketToken,
                pairs,
                closeBracketToken)
        {
        }

        MapExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            SyntaxToken? mutKeywordToken,
            SyntaxToken hashToken,
            SyntaxToken openBracketToken,
            SeparatedSyntaxNodeList<MapExpressionPairNode> pairs,
            SyntaxToken closeBracketToken)
            : base(skipped, diagnostics, annotations)
        {
            MutKeywordToken = mutKeywordToken;
            if (mutKeywordToken != null)
                mutKeywordToken.Parent = this;

            HashToken = hashToken;
            hashToken.Parent = this;

            OpenBracketToken = openBracketToken;
            openBracketToken.Parent = this;

            Pairs = pairs;
            foreach (var child in pairs.Nodes)
                child.Parent = this;
            foreach (var child in pairs.Separators)
                child.Parent = this;

            CloseBracketToken = closeBracketToken;
            closeBracketToken.Parent = this;
        }

        public MapExpressionNode DeepClone()
        {
            return new MapExpressionNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                MutKeywordToken?.DeepClone(),
                HashToken.DeepClone(),
                OpenBracketToken.DeepClone(),
                Pairs.DeepClone(),
                CloseBracketToken.DeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            if (MutKeywordToken != null)
                yield return MutKeywordToken;

            yield return HashToken;

            yield return OpenBracketToken;

            foreach (var token in Pairs.Separators)
                yield return token;

            yield return CloseBracketToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            foreach (var child in Pairs.Nodes)
                yield return child;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class MapExpressionPairNode : SyntaxNode
    {
        public ExpressionNode Key { get; }

        public SyntaxToken ColonToken { get; }

        public ExpressionNode Value { get; }

        public override bool HasTokens => true;

        public override bool HasChildren => true;

        internal MapExpressionPairNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ExpressionNode key,
            SyntaxToken colonToken,
            ExpressionNode value)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                key,
                colonToken,
                value)
        {
        }

        MapExpressionPairNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            ExpressionNode key,
            SyntaxToken colonToken,
            ExpressionNode value)
            : base(skipped, diagnostics, annotations)
        {
            Key = key;
            key.Parent = this;

            ColonToken = colonToken;
            colonToken.Parent = this;

            Value = value;
            value.Parent = this;
        }

        public MapExpressionPairNode DeepClone()
        {
            return new MapExpressionPairNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                (ExpressionNode)Key.InternalDeepClone(),
                ColonToken.DeepClone(),
                (ExpressionNode)Value.InternalDeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            yield return ColonToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            yield return Key;

            yield return Value;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class BlockExpressionNode : PrimaryExpressionNode
    {
        public SyntaxToken OpenBraceToken { get; }

        public SyntaxNodeList<StatementNode> Statements { get; }

        public SyntaxToken CloseBraceToken { get; }

        public override bool HasTokens => true;

        public override bool HasChildren
        {
            get
            {
                if (Statements.Count != 0)
                    return true;

                return false;
            }
        }

        internal BlockExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            SyntaxToken openBraceToken,
            SyntaxNodeList<StatementNode> statements,
            SyntaxToken closeBraceToken)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                openBraceToken,
                statements,
                closeBraceToken)
        {
        }

        BlockExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            SyntaxToken openBraceToken,
            SyntaxNodeList<StatementNode> statements,
            SyntaxToken closeBraceToken)
            : base(skipped, diagnostics, annotations)
        {
            OpenBraceToken = openBraceToken;
            openBraceToken.Parent = this;

            Statements = statements;
            foreach (var child in statements)
                child.Parent = this;

            CloseBraceToken = closeBraceToken;
            closeBraceToken.Parent = this;
        }

        public BlockExpressionNode DeepClone()
        {
            return new BlockExpressionNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                OpenBraceToken.DeepClone(),
                Statements.DeepClone(),
                CloseBraceToken.DeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            yield return OpenBraceToken;

            yield return CloseBraceToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            foreach (var child in Statements)
                yield return child;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class IfExpressionNode : PrimaryExpressionNode
    {
        public SyntaxToken IfKeywordToken { get; }

        public ExpressionNode Condition { get; }

        public BlockExpressionNode ThenBody { get; }

        public IfExpressionElseNode? Else { get; }

        public override bool HasTokens => true;

        public override bool HasChildren => true;

        internal IfExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            SyntaxToken ifKeywordToken,
            ExpressionNode condition,
            BlockExpressionNode thenBody,
            IfExpressionElseNode? @else)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                ifKeywordToken,
                condition,
                thenBody,
                @else)
        {
        }

        IfExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            SyntaxToken ifKeywordToken,
            ExpressionNode condition,
            BlockExpressionNode thenBody,
            IfExpressionElseNode? @else)
            : base(skipped, diagnostics, annotations)
        {
            IfKeywordToken = ifKeywordToken;
            ifKeywordToken.Parent = this;

            Condition = condition;
            condition.Parent = this;

            ThenBody = thenBody;
            thenBody.Parent = this;

            Else = @else;
            if (@else != null)
                @else.Parent = this;
        }

        public IfExpressionNode DeepClone()
        {
            return new IfExpressionNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                IfKeywordToken.DeepClone(),
                (ExpressionNode)Condition.InternalDeepClone(),
                (BlockExpressionNode)ThenBody.InternalDeepClone(),
                (IfExpressionElseNode?)Else?.InternalDeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            yield return IfKeywordToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            yield return Condition;

            yield return ThenBody;

            if (Else != null)
                yield return Else;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class IfExpressionElseNode : SyntaxNode
    {
        public SyntaxToken ElseKeywordToken { get; }

        public BlockExpressionNode ElseBody { get; }

        public override bool HasTokens => true;

        public override bool HasChildren => true;

        internal IfExpressionElseNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            SyntaxToken elseKeywordToken,
            BlockExpressionNode elseBody)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                elseKeywordToken,
                elseBody)
        {
        }

        IfExpressionElseNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            SyntaxToken elseKeywordToken,
            BlockExpressionNode elseBody)
            : base(skipped, diagnostics, annotations)
        {
            ElseKeywordToken = elseKeywordToken;
            elseKeywordToken.Parent = this;

            ElseBody = elseBody;
            elseBody.Parent = this;
        }

        public IfExpressionElseNode DeepClone()
        {
            return new IfExpressionElseNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                ElseKeywordToken.DeepClone(),
                (BlockExpressionNode)ElseBody.InternalDeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            yield return ElseKeywordToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            yield return ElseBody;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class ConditionExpressionNode : PrimaryExpressionNode
    {
        public SyntaxToken CondKeywordToken { get; }

        public SyntaxToken OpenBraceToken { get; }

        public SyntaxNodeList<ConditionExpressionArmNode> Arms { get; }

        public SyntaxToken CloseBraceToken { get; }

        public override bool HasTokens => true;

        public override bool HasChildren
        {
            get
            {
                if (Arms.Count != 0)
                    return true;

                return false;
            }
        }

        internal ConditionExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            SyntaxToken condKeywordToken,
            SyntaxToken openBraceToken,
            SyntaxNodeList<ConditionExpressionArmNode> arms,
            SyntaxToken closeBraceToken)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                condKeywordToken,
                openBraceToken,
                arms,
                closeBraceToken)
        {
        }

        ConditionExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            SyntaxToken condKeywordToken,
            SyntaxToken openBraceToken,
            SyntaxNodeList<ConditionExpressionArmNode> arms,
            SyntaxToken closeBraceToken)
            : base(skipped, diagnostics, annotations)
        {
            CondKeywordToken = condKeywordToken;
            condKeywordToken.Parent = this;

            OpenBraceToken = openBraceToken;
            openBraceToken.Parent = this;

            Arms = arms;
            foreach (var child in arms)
                child.Parent = this;

            CloseBraceToken = closeBraceToken;
            closeBraceToken.Parent = this;
        }

        public ConditionExpressionNode DeepClone()
        {
            return new ConditionExpressionNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                CondKeywordToken.DeepClone(),
                OpenBraceToken.DeepClone(),
                Arms.DeepClone(),
                CloseBraceToken.DeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            yield return CondKeywordToken;

            yield return OpenBraceToken;

            yield return CloseBraceToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            foreach (var child in Arms)
                yield return child;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class ConditionExpressionArmNode : SyntaxNode
    {
        public ExpressionNode Condition { get; }

        public SyntaxToken ArrowToken { get; }

        public ExpressionNode Body { get; }

        public SyntaxToken SemicolonToken { get; }

        public override bool HasTokens => true;

        public override bool HasChildren => true;

        internal ConditionExpressionArmNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ExpressionNode condition,
            SyntaxToken arrowToken,
            ExpressionNode body,
            SyntaxToken semicolonToken)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                condition,
                arrowToken,
                body,
                semicolonToken)
        {
        }

        ConditionExpressionArmNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            ExpressionNode condition,
            SyntaxToken arrowToken,
            ExpressionNode body,
            SyntaxToken semicolonToken)
            : base(skipped, diagnostics, annotations)
        {
            Condition = condition;
            condition.Parent = this;

            ArrowToken = arrowToken;
            arrowToken.Parent = this;

            Body = body;
            body.Parent = this;

            SemicolonToken = semicolonToken;
            semicolonToken.Parent = this;
        }

        public ConditionExpressionArmNode DeepClone()
        {
            return new ConditionExpressionArmNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                (ExpressionNode)Condition.InternalDeepClone(),
                ArrowToken.DeepClone(),
                (ExpressionNode)Body.InternalDeepClone(),
                SemicolonToken.DeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            yield return ArrowToken;

            yield return SemicolonToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            yield return Condition;

            yield return Body;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class MatchExpressionNode : PrimaryExpressionNode
    {
        public SyntaxToken MatchKeywordToken { get; }

        public ExpressionNode Operand { get; }

        public SyntaxToken OpenBraceToken { get; }

        public SyntaxNodeList<PatternArmNode> Arms { get; }

        public SyntaxToken CloseBraceToken { get; }

        public override bool HasTokens => true;

        public override bool HasChildren => true;

        internal MatchExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            SyntaxToken matchKeywordToken,
            ExpressionNode operand,
            SyntaxToken openBraceToken,
            SyntaxNodeList<PatternArmNode> arms,
            SyntaxToken closeBraceToken)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                matchKeywordToken,
                operand,
                openBraceToken,
                arms,
                closeBraceToken)
        {
        }

        MatchExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            SyntaxToken matchKeywordToken,
            ExpressionNode operand,
            SyntaxToken openBraceToken,
            SyntaxNodeList<PatternArmNode> arms,
            SyntaxToken closeBraceToken)
            : base(skipped, diagnostics, annotations)
        {
            MatchKeywordToken = matchKeywordToken;
            matchKeywordToken.Parent = this;

            Operand = operand;
            operand.Parent = this;

            OpenBraceToken = openBraceToken;
            openBraceToken.Parent = this;

            Arms = arms;
            foreach (var child in arms)
                child.Parent = this;

            CloseBraceToken = closeBraceToken;
            closeBraceToken.Parent = this;
        }

        public MatchExpressionNode DeepClone()
        {
            return new MatchExpressionNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                MatchKeywordToken.DeepClone(),
                (ExpressionNode)Operand.InternalDeepClone(),
                OpenBraceToken.DeepClone(),
                Arms.DeepClone(),
                CloseBraceToken.DeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            yield return MatchKeywordToken;

            yield return OpenBraceToken;

            yield return CloseBraceToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            yield return Operand;

            foreach (var child in Arms)
                yield return child;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class ForExpressionNode : PrimaryExpressionNode
    {
        public SyntaxToken ForKeywordToken { get; }

        public PatternNode Pattern { get; }

        public SyntaxToken InKeywordToken { get; }

        public ExpressionNode Collection { get; }

        public BlockExpressionNode Body { get; }

        public override bool HasTokens => true;

        public override bool HasChildren => true;

        internal ForExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            SyntaxToken forKeywordToken,
            PatternNode pattern,
            SyntaxToken inKeywordToken,
            ExpressionNode collection,
            BlockExpressionNode body)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                forKeywordToken,
                pattern,
                inKeywordToken,
                collection,
                body)
        {
        }

        ForExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            SyntaxToken forKeywordToken,
            PatternNode pattern,
            SyntaxToken inKeywordToken,
            ExpressionNode collection,
            BlockExpressionNode body)
            : base(skipped, diagnostics, annotations)
        {
            ForKeywordToken = forKeywordToken;
            forKeywordToken.Parent = this;

            Pattern = pattern;
            pattern.Parent = this;

            InKeywordToken = inKeywordToken;
            inKeywordToken.Parent = this;

            Collection = collection;
            collection.Parent = this;

            Body = body;
            body.Parent = this;
        }

        public ForExpressionNode DeepClone()
        {
            return new ForExpressionNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                ForKeywordToken.DeepClone(),
                (PatternNode)Pattern.InternalDeepClone(),
                InKeywordToken.DeepClone(),
                (ExpressionNode)Collection.InternalDeepClone(),
                (BlockExpressionNode)Body.InternalDeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            yield return ForKeywordToken;

            yield return InKeywordToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            yield return Pattern;

            yield return Collection;

            yield return Body;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class WhileExpressionNode : PrimaryExpressionNode
    {
        public SyntaxToken WhileKeywordToken { get; }

        public ExpressionNode Condition { get; }

        public BlockExpressionNode Body { get; }

        public override bool HasTokens => true;

        public override bool HasChildren => true;

        internal WhileExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            SyntaxToken whileKeywordToken,
            ExpressionNode condition,
            BlockExpressionNode body)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                whileKeywordToken,
                condition,
                body)
        {
        }

        WhileExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            SyntaxToken whileKeywordToken,
            ExpressionNode condition,
            BlockExpressionNode body)
            : base(skipped, diagnostics, annotations)
        {
            WhileKeywordToken = whileKeywordToken;
            whileKeywordToken.Parent = this;

            Condition = condition;
            condition.Parent = this;

            Body = body;
            body.Parent = this;
        }

        public WhileExpressionNode DeepClone()
        {
            return new WhileExpressionNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                WhileKeywordToken.DeepClone(),
                (ExpressionNode)Condition.InternalDeepClone(),
                (BlockExpressionNode)Body.InternalDeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            yield return WhileKeywordToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            yield return Condition;

            yield return Body;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class LoopExpressionNode : PrimaryExpressionNode
    {
        public SyntaxToken LoopKeywordToken { get; }

        public override bool HasTokens => true;

        public override bool HasChildren => false;

        internal LoopExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            SyntaxToken loopKeywordToken)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                loopKeywordToken)
        {
        }

        LoopExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            SyntaxToken loopKeywordToken)
            : base(skipped, diagnostics, annotations)
        {
            LoopKeywordToken = loopKeywordToken;
            loopKeywordToken.Parent = this;
        }

        public LoopExpressionNode DeepClone()
        {
            return new LoopExpressionNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                LoopKeywordToken.DeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            yield return LoopKeywordToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            return Array.Empty<SyntaxNode>();
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class BreakExpressionNode : PrimaryExpressionNode
    {
        public SyntaxToken BreakKeywordToken { get; }

        public override bool HasTokens => true;

        public override bool HasChildren => false;

        internal BreakExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            SyntaxToken breakKeywordToken)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                breakKeywordToken)
        {
        }

        BreakExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            SyntaxToken breakKeywordToken)
            : base(skipped, diagnostics, annotations)
        {
            BreakKeywordToken = breakKeywordToken;
            breakKeywordToken.Parent = this;
        }

        public BreakExpressionNode DeepClone()
        {
            return new BreakExpressionNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                BreakKeywordToken.DeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            yield return BreakKeywordToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            return Array.Empty<SyntaxNode>();
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class ReceiveExpressionNode : PrimaryExpressionNode
    {
        public SyntaxToken RecvKeywordToken { get; }

        public SyntaxToken OpenBraceToken { get; }

        public SyntaxNodeList<PatternArmNode> Arms { get; }

        public SyntaxToken CloseBraceToken { get; }

        public ReceiveExpressionElseNode? Else { get; }

        public override bool HasTokens => true;

        public override bool HasChildren
        {
            get
            {
                if (Arms.Count != 0)
                    return true;

                if (Else != null)
                    return true;

                return false;
            }
        }

        internal ReceiveExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            SyntaxToken recvKeywordToken,
            SyntaxToken openBraceToken,
            SyntaxNodeList<PatternArmNode> arms,
            SyntaxToken closeBraceToken,
            ReceiveExpressionElseNode? @else)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                recvKeywordToken,
                openBraceToken,
                arms,
                closeBraceToken,
                @else)
        {
        }

        ReceiveExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            SyntaxToken recvKeywordToken,
            SyntaxToken openBraceToken,
            SyntaxNodeList<PatternArmNode> arms,
            SyntaxToken closeBraceToken,
            ReceiveExpressionElseNode? @else)
            : base(skipped, diagnostics, annotations)
        {
            RecvKeywordToken = recvKeywordToken;
            recvKeywordToken.Parent = this;

            OpenBraceToken = openBraceToken;
            openBraceToken.Parent = this;

            Arms = arms;
            foreach (var child in arms)
                child.Parent = this;

            CloseBraceToken = closeBraceToken;
            closeBraceToken.Parent = this;

            Else = @else;
            if (@else != null)
                @else.Parent = this;
        }

        public ReceiveExpressionNode DeepClone()
        {
            return new ReceiveExpressionNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                RecvKeywordToken.DeepClone(),
                OpenBraceToken.DeepClone(),
                Arms.DeepClone(),
                CloseBraceToken.DeepClone(),
                (ReceiveExpressionElseNode?)Else?.InternalDeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            yield return RecvKeywordToken;

            yield return OpenBraceToken;

            yield return CloseBraceToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            foreach (var child in Arms)
                yield return child;

            if (Else != null)
                yield return Else;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class ReceiveExpressionElseNode : SyntaxNode
    {
        public SyntaxToken ElseKeywordToken { get; }

        public BlockExpressionNode ElseBody { get; }

        public override bool HasTokens => true;

        public override bool HasChildren => true;

        internal ReceiveExpressionElseNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            SyntaxToken elseKeywordToken,
            BlockExpressionNode elseBody)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                elseKeywordToken,
                elseBody)
        {
        }

        ReceiveExpressionElseNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            SyntaxToken elseKeywordToken,
            BlockExpressionNode elseBody)
            : base(skipped, diagnostics, annotations)
        {
            ElseKeywordToken = elseKeywordToken;
            elseKeywordToken.Parent = this;

            ElseBody = elseBody;
            elseBody.Parent = this;
        }

        public ReceiveExpressionElseNode DeepClone()
        {
            return new ReceiveExpressionElseNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                ElseKeywordToken.DeepClone(),
                (BlockExpressionNode)ElseBody.InternalDeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            yield return ElseKeywordToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            yield return ElseBody;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class RaiseExpressionNode : PrimaryExpressionNode
    {
        public SyntaxToken RaiseKeywordToken { get; }

        public ExpressionNode Operand { get; }

        public override bool HasTokens => true;

        public override bool HasChildren => true;

        internal RaiseExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            SyntaxToken raiseKeywordToken,
            ExpressionNode operand)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                raiseKeywordToken,
                operand)
        {
        }

        RaiseExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            SyntaxToken raiseKeywordToken,
            ExpressionNode operand)
            : base(skipped, diagnostics, annotations)
        {
            RaiseKeywordToken = raiseKeywordToken;
            raiseKeywordToken.Parent = this;

            Operand = operand;
            operand.Parent = this;
        }

        public RaiseExpressionNode DeepClone()
        {
            return new RaiseExpressionNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                RaiseKeywordToken.DeepClone(),
                (ExpressionNode)Operand.InternalDeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            yield return RaiseKeywordToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            yield return Operand;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class FreezeExpressionNode : PrimaryExpressionNode
    {
        public SyntaxToken FreezeKeywordToken { get; }

        public SyntaxToken? InKeywordToken { get; }

        public ExpressionNode Operand { get; }

        public override bool HasTokens => true;

        public override bool HasChildren => true;

        internal FreezeExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            SyntaxToken freezeKeywordToken,
            SyntaxToken? inKeywordToken,
            ExpressionNode operand)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                freezeKeywordToken,
                inKeywordToken,
                operand)
        {
        }

        FreezeExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            SyntaxToken freezeKeywordToken,
            SyntaxToken? inKeywordToken,
            ExpressionNode operand)
            : base(skipped, diagnostics, annotations)
        {
            FreezeKeywordToken = freezeKeywordToken;
            freezeKeywordToken.Parent = this;

            InKeywordToken = inKeywordToken;
            if (inKeywordToken != null)
                inKeywordToken.Parent = this;

            Operand = operand;
            operand.Parent = this;
        }

        public FreezeExpressionNode DeepClone()
        {
            return new FreezeExpressionNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                FreezeKeywordToken.DeepClone(),
                InKeywordToken?.DeepClone(),
                (ExpressionNode)Operand.InternalDeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            yield return FreezeKeywordToken;

            if (InKeywordToken != null)
                yield return InKeywordToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            yield return Operand;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class ReturnExpressionNode : PrimaryExpressionNode
    {
        public SyntaxToken ReturnKeywordToken { get; }

        public ExpressionNode Operand { get; }

        public override bool HasTokens => true;

        public override bool HasChildren => true;

        internal ReturnExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            SyntaxToken returnKeywordToken,
            ExpressionNode operand)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                returnKeywordToken,
                operand)
        {
        }

        ReturnExpressionNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            SyntaxToken returnKeywordToken,
            ExpressionNode operand)
            : base(skipped, diagnostics, annotations)
        {
            ReturnKeywordToken = returnKeywordToken;
            returnKeywordToken.Parent = this;

            Operand = operand;
            operand.Parent = this;
        }

        public ReturnExpressionNode DeepClone()
        {
            return new ReturnExpressionNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                ReturnKeywordToken.DeepClone(),
                (ExpressionNode)Operand.InternalDeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            yield return ReturnKeywordToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            yield return Operand;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public abstract class PatternNode : SyntaxNode
    {
        public abstract PatternAliasNode? Alias { get; }

        private protected PatternNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations)
                : base(skipped, diagnostics, annotations)
        {
        }
    }

    public sealed class MissingPatternNode : PatternNode
    {
        public override PatternAliasNode? Alias { get; }

        public override bool HasTokens => false;

        public override bool HasChildren
        {
            get
            {
                if (Alias != null)
                    return true;

                return false;
            }
        }

        internal MissingPatternNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            PatternAliasNode? alias)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                alias)
        {
        }

        MissingPatternNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            PatternAliasNode? alias)
            : base(skipped, diagnostics, annotations)
        {
            Alias = alias;
            if (alias != null)
                alias.Parent = this;
        }

        public MissingPatternNode DeepClone()
        {
            return new MissingPatternNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                (PatternAliasNode?)Alias?.InternalDeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            return Array.Empty<SyntaxToken>();
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            if (Alias != null)
                yield return Alias;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class PatternAliasNode : SyntaxNode
    {
        public SyntaxToken AsKeywordToken { get; }

        public SyntaxToken? MutKeywordToken { get; }

        public SyntaxToken NameToken { get; }

        public override bool HasTokens => true;

        public override bool HasChildren => false;

        internal PatternAliasNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            SyntaxToken asKeywordToken,
            SyntaxToken? mutKeywordToken,
            SyntaxToken nameToken)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                asKeywordToken,
                mutKeywordToken,
                nameToken)
        {
        }

        PatternAliasNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            SyntaxToken asKeywordToken,
            SyntaxToken? mutKeywordToken,
            SyntaxToken nameToken)
            : base(skipped, diagnostics, annotations)
        {
            AsKeywordToken = asKeywordToken;
            asKeywordToken.Parent = this;

            MutKeywordToken = mutKeywordToken;
            if (mutKeywordToken != null)
                mutKeywordToken.Parent = this;

            NameToken = nameToken;
            nameToken.Parent = this;
        }

        public PatternAliasNode DeepClone()
        {
            return new PatternAliasNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                AsKeywordToken.DeepClone(),
                MutKeywordToken?.DeepClone(),
                NameToken.DeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            yield return AsKeywordToken;

            if (MutKeywordToken != null)
                yield return MutKeywordToken;

            yield return NameToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            return Array.Empty<SyntaxNode>();
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class IdentifierPatternNode : PatternNode
    {
        public SyntaxToken? MutKeywordToken { get; }

        public SyntaxToken IdentifierToken { get; }

        public override PatternAliasNode? Alias { get; }

        public override bool HasTokens => true;

        public override bool HasChildren
        {
            get
            {
                if (Alias != null)
                    return true;

                return false;
            }
        }

        internal IdentifierPatternNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            SyntaxToken? mutKeywordToken,
            SyntaxToken identifierToken,
            PatternAliasNode? alias)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                mutKeywordToken,
                identifierToken,
                alias)
        {
        }

        IdentifierPatternNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            SyntaxToken? mutKeywordToken,
            SyntaxToken identifierToken,
            PatternAliasNode? alias)
            : base(skipped, diagnostics, annotations)
        {
            MutKeywordToken = mutKeywordToken;
            if (mutKeywordToken != null)
                mutKeywordToken.Parent = this;

            IdentifierToken = identifierToken;
            identifierToken.Parent = this;

            Alias = alias;
            if (alias != null)
                alias.Parent = this;
        }

        public IdentifierPatternNode DeepClone()
        {
            return new IdentifierPatternNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                MutKeywordToken?.DeepClone(),
                IdentifierToken.DeepClone(),
                (PatternAliasNode?)Alias?.InternalDeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            if (MutKeywordToken != null)
                yield return MutKeywordToken;

            yield return IdentifierToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            if (Alias != null)
                yield return Alias;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class LiteralPatternNode : PatternNode
    {
        public SyntaxToken? MinusToken { get; }

        public SyntaxToken ValueToken { get; }

        public override PatternAliasNode? Alias { get; }

        public override bool HasTokens => true;

        public override bool HasChildren
        {
            get
            {
                if (Alias != null)
                    return true;

                return false;
            }
        }

        internal LiteralPatternNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            SyntaxToken? minusToken,
            SyntaxToken valueToken,
            PatternAliasNode? alias)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                minusToken,
                valueToken,
                alias)
        {
        }

        LiteralPatternNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            SyntaxToken? minusToken,
            SyntaxToken valueToken,
            PatternAliasNode? alias)
            : base(skipped, diagnostics, annotations)
        {
            MinusToken = minusToken;
            if (minusToken != null)
                minusToken.Parent = this;

            ValueToken = valueToken;
            valueToken.Parent = this;

            Alias = alias;
            if (alias != null)
                alias.Parent = this;
        }

        public LiteralPatternNode DeepClone()
        {
            return new LiteralPatternNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                MinusToken?.DeepClone(),
                ValueToken.DeepClone(),
                (PatternAliasNode?)Alias?.InternalDeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            if (MinusToken != null)
                yield return MinusToken;

            yield return ValueToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            if (Alias != null)
                yield return Alias;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class ModulePatternNode : PatternNode
    {
        public ModulePathNode Path { get; }

        public override PatternAliasNode? Alias { get; }

        public override bool HasTokens => false;

        public override bool HasChildren => true;

        internal ModulePatternNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ModulePathNode path,
            PatternAliasNode? alias)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                path,
                alias)
        {
        }

        ModulePatternNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            ModulePathNode path,
            PatternAliasNode? alias)
            : base(skipped, diagnostics, annotations)
        {
            Path = path;
            path.Parent = this;

            Alias = alias;
            if (alias != null)
                alias.Parent = this;
        }

        public ModulePatternNode DeepClone()
        {
            return new ModulePatternNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                (ModulePathNode)Path.InternalDeepClone(),
                (PatternAliasNode?)Alias?.InternalDeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            return Array.Empty<SyntaxToken>();
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            yield return Path;

            if (Alias != null)
                yield return Alias;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class TuplePatternNode : PatternNode
    {
        public SyntaxToken OpenParenToken { get; }

        public SeparatedSyntaxNodeList<PatternNode> Components { get; }

        public SyntaxToken CloseParenToken { get; }

        public override PatternAliasNode? Alias { get; }

        public override bool HasTokens => true;

        public override bool HasChildren
        {
            get
            {
                if (Components.Nodes.Count != 0)
                    return true;

                if (Alias != null)
                    return true;

                return false;
            }
        }

        internal TuplePatternNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            SyntaxToken openParenToken,
            SeparatedSyntaxNodeList<PatternNode> components,
            SyntaxToken closeParenToken,
            PatternAliasNode? alias)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                openParenToken,
                components,
                closeParenToken,
                alias)
        {
        }

        TuplePatternNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            SyntaxToken openParenToken,
            SeparatedSyntaxNodeList<PatternNode> components,
            SyntaxToken closeParenToken,
            PatternAliasNode? alias)
            : base(skipped, diagnostics, annotations)
        {
            OpenParenToken = openParenToken;
            openParenToken.Parent = this;

            Components = components;
            foreach (var child in components.Nodes)
                child.Parent = this;
            foreach (var child in components.Separators)
                child.Parent = this;

            CloseParenToken = closeParenToken;
            closeParenToken.Parent = this;

            Alias = alias;
            if (alias != null)
                alias.Parent = this;
        }

        public TuplePatternNode DeepClone()
        {
            return new TuplePatternNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                OpenParenToken.DeepClone(),
                Components.DeepClone(),
                CloseParenToken.DeepClone(),
                (PatternAliasNode?)Alias?.InternalDeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            yield return OpenParenToken;

            foreach (var token in Components.Separators)
                yield return token;

            yield return CloseParenToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            foreach (var child in Components.Nodes)
                yield return child;

            if (Alias != null)
                yield return Alias;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class RecordPatternNode : PatternNode
    {
        public SyntaxToken RecKeywordToken { get; }

        public SyntaxToken? NameToken { get; }

        public SyntaxToken OpenBraceToken { get; }

        public SeparatedSyntaxNodeList<PatternFieldNode> Fields { get; }

        public SyntaxToken CloseBraceToken { get; }

        public override PatternAliasNode? Alias { get; }

        public override bool HasTokens => true;

        public override bool HasChildren
        {
            get
            {
                if (Fields.Nodes.Count != 0)
                    return true;

                if (Alias != null)
                    return true;

                return false;
            }
        }

        internal RecordPatternNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            SyntaxToken recKeywordToken,
            SyntaxToken? nameToken,
            SyntaxToken openBraceToken,
            SeparatedSyntaxNodeList<PatternFieldNode> fields,
            SyntaxToken closeBraceToken,
            PatternAliasNode? alias)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                recKeywordToken,
                nameToken,
                openBraceToken,
                fields,
                closeBraceToken,
                alias)
        {
        }

        RecordPatternNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            SyntaxToken recKeywordToken,
            SyntaxToken? nameToken,
            SyntaxToken openBraceToken,
            SeparatedSyntaxNodeList<PatternFieldNode> fields,
            SyntaxToken closeBraceToken,
            PatternAliasNode? alias)
            : base(skipped, diagnostics, annotations)
        {
            RecKeywordToken = recKeywordToken;
            recKeywordToken.Parent = this;

            NameToken = nameToken;
            if (nameToken != null)
                nameToken.Parent = this;

            OpenBraceToken = openBraceToken;
            openBraceToken.Parent = this;

            Fields = fields;
            foreach (var child in fields.Nodes)
                child.Parent = this;
            foreach (var child in fields.Separators)
                child.Parent = this;

            CloseBraceToken = closeBraceToken;
            closeBraceToken.Parent = this;

            Alias = alias;
            if (alias != null)
                alias.Parent = this;
        }

        public RecordPatternNode DeepClone()
        {
            return new RecordPatternNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                RecKeywordToken.DeepClone(),
                NameToken?.DeepClone(),
                OpenBraceToken.DeepClone(),
                Fields.DeepClone(),
                CloseBraceToken.DeepClone(),
                (PatternAliasNode?)Alias?.InternalDeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            yield return RecKeywordToken;

            if (NameToken != null)
                yield return NameToken;

            yield return OpenBraceToken;

            foreach (var token in Fields.Separators)
                yield return token;

            yield return CloseBraceToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            foreach (var child in Fields.Nodes)
                yield return child;

            if (Alias != null)
                yield return Alias;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class PatternFieldNode : SyntaxNode
    {
        public SyntaxToken NameToken { get; }

        public SyntaxToken EqualsToken { get; }

        public PatternNode Pattern { get; }

        public override bool HasTokens => true;

        public override bool HasChildren => true;

        internal PatternFieldNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            SyntaxToken nameToken,
            SyntaxToken equalsToken,
            PatternNode pattern)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                nameToken,
                equalsToken,
                pattern)
        {
        }

        PatternFieldNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            SyntaxToken nameToken,
            SyntaxToken equalsToken,
            PatternNode pattern)
            : base(skipped, diagnostics, annotations)
        {
            NameToken = nameToken;
            nameToken.Parent = this;

            EqualsToken = equalsToken;
            equalsToken.Parent = this;

            Pattern = pattern;
            pattern.Parent = this;
        }

        public PatternFieldNode DeepClone()
        {
            return new PatternFieldNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                NameToken.DeepClone(),
                EqualsToken.DeepClone(),
                (PatternNode)Pattern.InternalDeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            yield return NameToken;

            yield return EqualsToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            yield return Pattern;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class ExceptionPatternNode : PatternNode
    {
        public SyntaxToken ExcKeywordToken { get; }

        public SyntaxToken NameToken { get; }

        public SyntaxToken OpenBraceToken { get; }

        public SeparatedSyntaxNodeList<PatternFieldNode> Fields { get; }

        public SyntaxToken CloseBraceToken { get; }

        public override PatternAliasNode? Alias { get; }

        public override bool HasTokens => true;

        public override bool HasChildren
        {
            get
            {
                if (Fields.Nodes.Count != 0)
                    return true;

                if (Alias != null)
                    return true;

                return false;
            }
        }

        internal ExceptionPatternNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            SyntaxToken excKeywordToken,
            SyntaxToken nameToken,
            SyntaxToken openBraceToken,
            SeparatedSyntaxNodeList<PatternFieldNode> fields,
            SyntaxToken closeBraceToken,
            PatternAliasNode? alias)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                excKeywordToken,
                nameToken,
                openBraceToken,
                fields,
                closeBraceToken,
                alias)
        {
        }

        ExceptionPatternNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            SyntaxToken excKeywordToken,
            SyntaxToken nameToken,
            SyntaxToken openBraceToken,
            SeparatedSyntaxNodeList<PatternFieldNode> fields,
            SyntaxToken closeBraceToken,
            PatternAliasNode? alias)
            : base(skipped, diagnostics, annotations)
        {
            ExcKeywordToken = excKeywordToken;
            excKeywordToken.Parent = this;

            NameToken = nameToken;
            nameToken.Parent = this;

            OpenBraceToken = openBraceToken;
            openBraceToken.Parent = this;

            Fields = fields;
            foreach (var child in fields.Nodes)
                child.Parent = this;
            foreach (var child in fields.Separators)
                child.Parent = this;

            CloseBraceToken = closeBraceToken;
            closeBraceToken.Parent = this;

            Alias = alias;
            if (alias != null)
                alias.Parent = this;
        }

        public ExceptionPatternNode DeepClone()
        {
            return new ExceptionPatternNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                ExcKeywordToken.DeepClone(),
                NameToken.DeepClone(),
                OpenBraceToken.DeepClone(),
                Fields.DeepClone(),
                CloseBraceToken.DeepClone(),
                (PatternAliasNode?)Alias?.InternalDeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            yield return ExcKeywordToken;

            yield return NameToken;

            yield return OpenBraceToken;

            foreach (var token in Fields.Separators)
                yield return token;

            yield return CloseBraceToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            foreach (var child in Fields.Nodes)
                yield return child;

            if (Alias != null)
                yield return Alias;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class ArrayPatternNode : PatternNode
    {
        public SyntaxToken OpenBracketToken { get; }

        public SeparatedSyntaxNodeList<PatternNode> Elements { get; }

        public SyntaxToken CloseBracketToken { get; }

        public ArrayPatternRemainderNode? Remainder { get; }

        public override PatternAliasNode? Alias { get; }

        public override bool HasTokens => true;

        public override bool HasChildren
        {
            get
            {
                if (Elements.Nodes.Count != 0)
                    return true;

                if (Remainder != null)
                    return true;

                if (Alias != null)
                    return true;

                return false;
            }
        }

        internal ArrayPatternNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            SyntaxToken openBracketToken,
            SeparatedSyntaxNodeList<PatternNode> elements,
            SyntaxToken closeBracketToken,
            ArrayPatternRemainderNode? remainder,
            PatternAliasNode? alias)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                openBracketToken,
                elements,
                closeBracketToken,
                remainder,
                alias)
        {
        }

        ArrayPatternNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            SyntaxToken openBracketToken,
            SeparatedSyntaxNodeList<PatternNode> elements,
            SyntaxToken closeBracketToken,
            ArrayPatternRemainderNode? remainder,
            PatternAliasNode? alias)
            : base(skipped, diagnostics, annotations)
        {
            OpenBracketToken = openBracketToken;
            openBracketToken.Parent = this;

            Elements = elements;
            foreach (var child in elements.Nodes)
                child.Parent = this;
            foreach (var child in elements.Separators)
                child.Parent = this;

            CloseBracketToken = closeBracketToken;
            closeBracketToken.Parent = this;

            Remainder = remainder;
            if (remainder != null)
                remainder.Parent = this;

            Alias = alias;
            if (alias != null)
                alias.Parent = this;
        }

        public ArrayPatternNode DeepClone()
        {
            return new ArrayPatternNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                OpenBracketToken.DeepClone(),
                Elements.DeepClone(),
                CloseBracketToken.DeepClone(),
                (ArrayPatternRemainderNode?)Remainder?.InternalDeepClone(),
                (PatternAliasNode?)Alias?.InternalDeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            yield return OpenBracketToken;

            foreach (var token in Elements.Separators)
                yield return token;

            yield return CloseBracketToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            foreach (var child in Elements.Nodes)
                yield return child;

            if (Remainder != null)
                yield return Remainder;

            if (Alias != null)
                yield return Alias;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class ArrayPatternRemainderNode : SyntaxNode
    {
        public SyntaxToken ColonColonToken { get; }

        public PatternNode Pattern { get; }

        public override bool HasTokens => true;

        public override bool HasChildren => true;

        internal ArrayPatternRemainderNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            SyntaxToken colonColonToken,
            PatternNode pattern)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                colonColonToken,
                pattern)
        {
        }

        ArrayPatternRemainderNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            SyntaxToken colonColonToken,
            PatternNode pattern)
            : base(skipped, diagnostics, annotations)
        {
            ColonColonToken = colonColonToken;
            colonColonToken.Parent = this;

            Pattern = pattern;
            pattern.Parent = this;
        }

        public ArrayPatternRemainderNode DeepClone()
        {
            return new ArrayPatternRemainderNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                ColonColonToken.DeepClone(),
                (PatternNode)Pattern.InternalDeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            yield return ColonColonToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            yield return Pattern;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class SetPatternNode : PatternNode
    {
        public SyntaxToken HashToken { get; }

        public SyntaxToken OpenBraceToken { get; }

        public SeparatedSyntaxNodeList<ExpressionNode> Elements { get; }

        public SyntaxToken CloseBraceToken { get; }

        public override PatternAliasNode? Alias { get; }

        public override bool HasTokens => true;

        public override bool HasChildren
        {
            get
            {
                if (Elements.Nodes.Count != 0)
                    return true;

                if (Alias != null)
                    return true;

                return false;
            }
        }

        internal SetPatternNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            SyntaxToken hashToken,
            SyntaxToken openBraceToken,
            SeparatedSyntaxNodeList<ExpressionNode> elements,
            SyntaxToken closeBraceToken,
            PatternAliasNode? alias)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                hashToken,
                openBraceToken,
                elements,
                closeBraceToken,
                alias)
        {
        }

        SetPatternNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            SyntaxToken hashToken,
            SyntaxToken openBraceToken,
            SeparatedSyntaxNodeList<ExpressionNode> elements,
            SyntaxToken closeBraceToken,
            PatternAliasNode? alias)
            : base(skipped, diagnostics, annotations)
        {
            HashToken = hashToken;
            hashToken.Parent = this;

            OpenBraceToken = openBraceToken;
            openBraceToken.Parent = this;

            Elements = elements;
            foreach (var child in elements.Nodes)
                child.Parent = this;
            foreach (var child in elements.Separators)
                child.Parent = this;

            CloseBraceToken = closeBraceToken;
            closeBraceToken.Parent = this;

            Alias = alias;
            if (alias != null)
                alias.Parent = this;
        }

        public SetPatternNode DeepClone()
        {
            return new SetPatternNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                HashToken.DeepClone(),
                OpenBraceToken.DeepClone(),
                Elements.DeepClone(),
                CloseBraceToken.DeepClone(),
                (PatternAliasNode?)Alias?.InternalDeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            yield return HashToken;

            yield return OpenBraceToken;

            foreach (var token in Elements.Separators)
                yield return token;

            yield return CloseBraceToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            foreach (var child in Elements.Nodes)
                yield return child;

            if (Alias != null)
                yield return Alias;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class MapPatternNode : PatternNode
    {
        public SyntaxToken HashToken { get; }

        public SyntaxToken OpenBracketToken { get; }

        public SeparatedSyntaxNodeList<MapPatternPairNode> Pairs { get; }

        public SyntaxToken CloseBracketToken { get; }

        public override PatternAliasNode? Alias { get; }

        public override bool HasTokens => true;

        public override bool HasChildren
        {
            get
            {
                if (Pairs.Nodes.Count != 0)
                    return true;

                if (Alias != null)
                    return true;

                return false;
            }
        }

        internal MapPatternNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            SyntaxToken hashToken,
            SyntaxToken openBracketToken,
            SeparatedSyntaxNodeList<MapPatternPairNode> pairs,
            SyntaxToken closeBracketToken,
            PatternAliasNode? alias)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                hashToken,
                openBracketToken,
                pairs,
                closeBracketToken,
                alias)
        {
        }

        MapPatternNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            SyntaxToken hashToken,
            SyntaxToken openBracketToken,
            SeparatedSyntaxNodeList<MapPatternPairNode> pairs,
            SyntaxToken closeBracketToken,
            PatternAliasNode? alias)
            : base(skipped, diagnostics, annotations)
        {
            HashToken = hashToken;
            hashToken.Parent = this;

            OpenBracketToken = openBracketToken;
            openBracketToken.Parent = this;

            Pairs = pairs;
            foreach (var child in pairs.Nodes)
                child.Parent = this;
            foreach (var child in pairs.Separators)
                child.Parent = this;

            CloseBracketToken = closeBracketToken;
            closeBracketToken.Parent = this;

            Alias = alias;
            if (alias != null)
                alias.Parent = this;
        }

        public MapPatternNode DeepClone()
        {
            return new MapPatternNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                HashToken.DeepClone(),
                OpenBracketToken.DeepClone(),
                Pairs.DeepClone(),
                CloseBracketToken.DeepClone(),
                (PatternAliasNode?)Alias?.InternalDeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            yield return HashToken;

            yield return OpenBracketToken;

            foreach (var token in Pairs.Separators)
                yield return token;

            yield return CloseBracketToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            foreach (var child in Pairs.Nodes)
                yield return child;

            if (Alias != null)
                yield return Alias;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public sealed class MapPatternPairNode : SyntaxNode
    {
        public ExpressionNode Key { get; }

        public SyntaxToken ColonToken { get; }

        public PatternNode Value { get; }

        public override bool HasTokens => true;

        public override bool HasChildren => true;

        internal MapPatternPairNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ExpressionNode key,
            SyntaxToken colonToken,
            PatternNode value)
            : this(
                skipped,
                diagnostics,
                ImmutableDictionary<string, object>.Empty,
                key,
                colonToken,
                value)
        {
        }

        MapPatternPairNode(
            ImmutableArray<SyntaxToken> skipped,
            ImmutableArray<SyntaxDiagnostic> diagnostics,
            ImmutableDictionary<string, object> annotations,
            ExpressionNode key,
            SyntaxToken colonToken,
            PatternNode value)
            : base(skipped, diagnostics, annotations)
        {
            Key = key;
            key.Parent = this;

            ColonToken = colonToken;
            colonToken.Parent = this;

            Value = value;
            value.Parent = this;
        }

        public MapPatternPairNode DeepClone()
        {
            return new MapPatternPairNode(
                SkippedTokens.Select(x => x.DeepClone()).ToImmutableArray(),
                Diagnostics,
                Annotations,
                (ExpressionNode)Key.InternalDeepClone(),
                ColonToken.DeepClone(),
                (PatternNode)Value.InternalDeepClone());
        }

        internal override SyntaxNode InternalDeepClone()
        {
            return DeepClone();
        }

        public override IEnumerable<SyntaxToken> Tokens()
        {
            yield return ColonToken;
        }

        public override IEnumerable<SyntaxNode> Children()
        {
            yield return Key;

            yield return Value;
        }

        internal override void Accept(SyntaxVisitor visitor)
        {
            visitor.Visit(this);
        }

        internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)
        {
            return visitor.Visit(this, state);
        }
    }

    public partial class SyntaxVisitor
    {
        public virtual void Visit(ModulePathNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(ProgramNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(InteractiveNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(AttributeNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(UseDeclarationNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(UseDeclarationAliasNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(TestDeclarationNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(MissingNamedDeclarationNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(ConstantDeclarationNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(FunctionDeclarationNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(FunctionParameterListNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(FunctionParameterNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(ExternalDeclarationNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(LetStatementNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(UseStatementNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(ExpressionStatementNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(MissingExpressionNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(UnaryExpressionNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(AssertExpressionNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(SendExpressionNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(AssignExpressionNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(LogicalExpressionNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(RelationalExpressionNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(BitwiseExpressionNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(ShiftExpressionNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(AdditiveExpressionNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(MultiplicativeExpressionNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(CallExpressionNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(ArgumentListNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(ArgumentNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(CallTryNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(CallTryCatchNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(PatternArmNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(PatternArmGuardNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(MethodCallExpressionNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(IndexExpressionNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(IndexListNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(IndexNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(FieldAccessExpressionNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(ParenthesizedExpressionNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(IdentifierExpressionNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(LiteralExpressionNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(LambdaExpressionNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(LambdaParameterListNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(LambdaParameterNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(ModuleExpressionNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(RecordExpressionNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(ExpressionFieldNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(ExceptionExpressionNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(TupleExpressionNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(ArrayExpressionNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(SetExpressionNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(MapExpressionNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(MapExpressionPairNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(BlockExpressionNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(IfExpressionNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(IfExpressionElseNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(ConditionExpressionNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(ConditionExpressionArmNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(MatchExpressionNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(ForExpressionNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(WhileExpressionNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(LoopExpressionNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(BreakExpressionNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(ReceiveExpressionNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(ReceiveExpressionElseNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(RaiseExpressionNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(FreezeExpressionNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(ReturnExpressionNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(MissingPatternNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(PatternAliasNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(IdentifierPatternNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(LiteralPatternNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(ModulePatternNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(TuplePatternNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(RecordPatternNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(PatternFieldNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(ExceptionPatternNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(ArrayPatternNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(ArrayPatternRemainderNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(SetPatternNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(MapPatternNode node)
        {
            DefaultVisit(node);
        }

        public virtual void Visit(MapPatternPairNode node)
        {
            DefaultVisit(node);
        }
    }

    public partial class SyntaxVisitor<T>
    {
        public virtual T Visit(ModulePathNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(ProgramNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(InteractiveNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(AttributeNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(UseDeclarationNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(UseDeclarationAliasNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(TestDeclarationNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(MissingNamedDeclarationNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(ConstantDeclarationNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(FunctionDeclarationNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(FunctionParameterListNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(FunctionParameterNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(ExternalDeclarationNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(LetStatementNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(UseStatementNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(ExpressionStatementNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(MissingExpressionNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(UnaryExpressionNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(AssertExpressionNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(SendExpressionNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(AssignExpressionNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(LogicalExpressionNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(RelationalExpressionNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(BitwiseExpressionNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(ShiftExpressionNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(AdditiveExpressionNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(MultiplicativeExpressionNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(CallExpressionNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(ArgumentListNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(ArgumentNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(CallTryNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(CallTryCatchNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(PatternArmNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(PatternArmGuardNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(MethodCallExpressionNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(IndexExpressionNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(IndexListNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(IndexNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(FieldAccessExpressionNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(ParenthesizedExpressionNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(IdentifierExpressionNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(LiteralExpressionNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(LambdaExpressionNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(LambdaParameterListNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(LambdaParameterNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(ModuleExpressionNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(RecordExpressionNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(ExpressionFieldNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(ExceptionExpressionNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(TupleExpressionNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(ArrayExpressionNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(SetExpressionNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(MapExpressionNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(MapExpressionPairNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(BlockExpressionNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(IfExpressionNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(IfExpressionElseNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(ConditionExpressionNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(ConditionExpressionArmNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(MatchExpressionNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(ForExpressionNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(WhileExpressionNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(LoopExpressionNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(BreakExpressionNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(ReceiveExpressionNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(ReceiveExpressionElseNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(RaiseExpressionNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(FreezeExpressionNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(ReturnExpressionNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(MissingPatternNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(PatternAliasNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(IdentifierPatternNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(LiteralPatternNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(ModulePatternNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(TuplePatternNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(RecordPatternNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(PatternFieldNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(ExceptionPatternNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(ArrayPatternNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(ArrayPatternRemainderNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(SetPatternNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(MapPatternNode node, T state)
        {
            return DefaultVisit(node, state);
        }

        public virtual T Visit(MapPatternPairNode node, T state)
        {
            return DefaultVisit(node, state);
        }
    }
}
